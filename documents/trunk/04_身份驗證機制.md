# EECOnline 身份驗證機制

## 1. 概述

EECOnline 系統支援多種身份驗證方式，針對不同使用者角色提供適當的認證機制。

### 1.1 驗證方式總覽

```mermaid
graph TB
    subgraph "前台民眾驗證"
        CERT[自然人憑證<br/>Citizen Digital Certificate]
        FIDO[行動自然人憑證<br/>TW FidO]
        HCA[健保卡驗證<br/>NHI Card]
    end
    
    subgraph "後台人員驗證"
        PWD[帳號密碼<br/>Username/Password]
        HOSP[醫院授權碼<br/>Hospital Auth Code]
    end
    
    subgraph "驗證結果"
        SESSION[建立 Session]
        ROLE[設定角色權限]
        MENU[載入功能選單]
    end
    
    CERT --> SESSION
    FIDO --> SESSION
    HCA --> SESSION
    PWD --> SESSION
    HOSP --> SESSION
    
    SESSION --> ROLE
    ROLE --> MENU
```

---

## 2. 前台民眾驗證

### 2.1 自然人憑證 (Citizen Digital Certificate)

```mermaid
sequenceDiagram
    participant User as 民眾
    participant Browser as 瀏覽器
    participant Component as 憑證元件
    participant Server as EECOnline
    participant MOICA as 憑證中心
    
    User->>Browser: 插入自然人憑證
    Browser->>Component: 啟動 ServiSign
    Component->>Component: 讀取憑證資訊
    Component->>User: 要求輸入 PIN
    User->>Component: 輸入 PIN
    Component->>Component: 產生數位簽章
    Component->>Server: 傳送簽章資料
    Server->>MOICA: 驗證憑證有效性
    MOICA-->>Server: 驗證結果
    Server->>Server: 取得身分證字號
    Server->>Server: 查詢/建立使用者
    Server->>Server: 建立 Session
    Server-->>Browser: 登入成功
```

#### 程式碼實作

```csharp
// Controllers/HomeController.cs
[HttpPost]
public ActionResult LoginForm1(string signData, string certData)
{
    try
    {
        // 1. 驗證簽章
        var verifyResult = VerifyCertSignature(signData, certData);
        if (!verifyResult.IsValid)
        {
            return Json(new { success = false, message = "憑證驗證失敗" });
        }
        
        // 2. 取得身分證字號
        string idn = ExtractIDNFromCert(certData);
        
        // 3. 查詢或建立使用者
        var user = _frontDAO.GetOrCreateUser(idn);
        
        // 4. 建立 Session
        CreateUserSession(user, LoginType.Certificate);
        
        return Json(new { success = true, redirectUrl = "/Home/Apply" });
    }
    catch (Exception ex)
    {
        LogUtils.Error("LoginForm1 Error", ex);
        return Json(new { success = false, message = "登入失敗" });
    }
}
```

### 2.2 行動自然人憑證 (TW FidO)

```mermaid
sequenceDiagram
    participant User as 民眾
    participant Browser as 瀏覽器
    participant Server as EECOnline
    participant FidO as TW FidO 服務
    participant Mobile as 手機 App
    
    User->>Browser: 選擇行動憑證登入
    Browser->>Server: 請求 QR Code
    Server->>FidO: 產生驗證請求
    FidO-->>Server: 回傳 QR Code 資料
    Server-->>Browser: 顯示 QR Code
    
    User->>Mobile: 開啟 TW FidO App
    Mobile->>Mobile: 掃描 QR Code
    Mobile->>User: 要求生物辨識
    User->>Mobile: 指紋/臉部辨識
    Mobile->>FidO: 傳送驗證結果
    FidO->>Server: 推送驗證完成
    Server->>Server: 取得身分證字號
    Server->>Server: 建立 Session
    Server-->>Browser: 登入成功
```

#### TW FidO 整合程式碼

```csharp
// Controllers/HomeController.cs
[HttpPost]
public ActionResult LoginForm2_GetQRCode()
{
    try
    {
        // 產生交易序號
        string transId = Guid.NewGuid().ToString("N");
        
        // 呼叫 TW FidO API 取得 QR Code
        var fidoService = new TWFidOService();
        var qrResult = fidoService.GenerateQRCode(transId);
        
        // 儲存交易序號至 Session
        Session["FidO_TransId"] = transId;
        
        return Json(new { 
            success = true, 
            qrCode = qrResult.QRCodeBase64,
            transId = transId
        });
    }
    catch (Exception ex)
    {
        LogUtils.Error("LoginForm2_GetQRCode Error", ex);
        return Json(new { success = false, message = "取得 QR Code 失敗" });
    }
}

[HttpPost]
public ActionResult LoginForm2_CheckStatus(string transId)
{
    try
    {
        var fidoService = new TWFidOService();
        var result = fidoService.CheckAuthStatus(transId);
        
        if (result.IsAuthenticated)
        {
            // 取得身分證字號
            string idn = result.IDN;
            
            // 查詢或建立使用者
            var user = _frontDAO.GetOrCreateUser(idn);
            
            // 建立 Session
            CreateUserSession(user, LoginType.FidO);
            
            return Json(new { 
                success = true, 
                status = "completed",
                redirectUrl = "/Home/Apply" 
            });
        }
        
        return Json(new { success = true, status = "pending" });
    }
    catch (Exception ex)
    {
        return Json(new { success = false, message = ex.Message });
    }
}
```

### 2.3 健保卡驗證 (HCA)

```mermaid
sequenceDiagram
    participant User as 民眾
    participant Browser as 瀏覽器
    participant HCA_JS as HCA JavaScript
    participant ServiSign as ServiSign 元件
    participant Server as EECOnline
    participant NHI as 健保署
    
    User->>Browser: 插入健保卡
    Browser->>HCA_JS: 初始化 HCA
    HCA_JS->>ServiSign: 載入元件
    ServiSign->>ServiSign: 偵測讀卡機
    ServiSign->>ServiSign: 讀取卡片資訊
    ServiSign->>User: 要求輸入 PIN
    User->>ServiSign: 輸入 PIN
    ServiSign->>ServiSign: 驗證 PIN
    ServiSign->>ServiSign: 產生簽章
    ServiSign->>HCA_JS: 回傳簽章資料
    HCA_JS->>Server: POST 驗證資料
    Server->>NHI: 驗證簽章
    NHI-->>Server: 驗證結果
    Server->>Server: 建立 Session
    Server-->>Browser: 登入成功
```

#### HCA JavaScript 模組

```javascript
// HCA/HCALogin.js
var HCALogin = {
    // 初始化
    init: function() {
        // 載入 ServiSign 元件
        HCAEvn.loadServiSign(function(success) {
            if (success) {
                HCALogin.checkCardReader();
            } else {
                alert("請安裝 ServiSign 元件");
            }
        });
    },
    
    // 檢查讀卡機
    checkCardReader: function() {
        HCAServiSign.getReaderList(function(readers) {
            if (readers.length === 0) {
                alert("未偵測到讀卡機");
                return;
            }
            HCALogin.selectReader(readers[0]);
        });
    },
    
    // 讀取卡片
    readCard: function() {
        HCAServiSign.readCard(function(cardInfo) {
            if (cardInfo.success) {
                HCALogin.cardData = cardInfo.data;
                $("#cardId").text(cardInfo.data.cardId);
            } else {
                alert("讀取卡片失敗: " + cardInfo.message);
            }
        });
    },
    
    // 驗證登入
    login: function() {
        // 產生簽章
        HCAServiSign.sign(HCALogin.cardData, function(signResult) {
            if (signResult.success) {
                // 傳送至伺服器驗證
                $.ajax({
                    url: '/Home/LoginForm3',
                    type: 'POST',
                    data: {
                        signData: signResult.signature,
                        certData: signResult.certificate
                    },
                    success: function(response) {
                        if (response.success) {
                            window.location.href = response.redirectUrl;
                        } else {
                            alert(response.message);
                        }
                    }
                });
            }
        });
    }
};
```

---

## 3. 後台人員驗證

### 3.1 帳號密碼登入

```mermaid
sequenceDiagram
    participant User as 管理員
    participant Browser as 瀏覽器
    participant Controller as LoginController
    participant DAO as LoginDAO
    participant DB as Database
    
    User->>Browser: 輸入帳號密碼
    Browser->>Controller: POST /Login/C101M/Login
    Controller->>Controller: 驗證驗證碼
    Controller->>DAO: QueryUserByAccount
    DAO->>DB: SELECT * FROM AMDBUSM
    DB-->>DAO: 使用者資料
    DAO-->>Controller: UserInfo
    Controller->>Controller: 驗證密碼 (SHA512)
    Controller->>Controller: 檢查帳號狀態
    Controller->>DAO: GetUserRoles
    DAO->>DB: SELECT Role/Permissions
    DB-->>DAO: 角色權限資料
    Controller->>Controller: 建立 Session
    Controller->>DAO: InsertLoginLog
    Controller-->>Browser: 登入成功
```

#### 密碼驗證程式碼

```csharp
// Areas/Login/Controllers/C101MController.cs
[HttpPost]
[BypassAuthorize]
public ActionResult Login(LoginModel model)
{
    try
    {
        // 1. 驗證驗證碼
        if (!ValidateCaptcha(model.Captcha))
        {
            return Json(new { success = false, message = "驗證碼錯誤" });
        }
        
        // 2. 查詢使用者
        var user = _loginDAO.QueryUserByAccount(model.Account);
        if (user == null)
        {
            return Json(new { success = false, message = "帳號或密碼錯誤" });
        }
        
        // 3. 檢查帳號狀態
        if (user.STATUS != "1")
        {
            return Json(new { success = false, message = "帳號已停用" });
        }
        
        // 4. 驗證密碼 (SHA512)
        string hashedPassword = CommonsServices.HashSHA512(model.Password);
        if (user.PASSWORD != hashedPassword)
        {
            // 記錄失敗次數
            _loginDAO.IncrementFailCount(user.USER_ID);
            
            // 檢查是否鎖定
            if (user.FAIL_COUNT >= 5)
            {
                _loginDAO.LockAccount(user.USER_ID);
                return Json(new { success = false, message = "帳號已鎖定，請聯繫管理員" });
            }
            
            return Json(new { success = false, message = "帳號或密碼錯誤" });
        }
        
        // 5. 重設失敗次數
        _loginDAO.ResetFailCount(user.USER_ID);
        
        // 6. 取得角色權限
        var roles = _loginDAO.GetUserRoles(user.USER_ID);
        var funcs = _loginDAO.GetUserFunctions(user.USER_ID);
        
        // 7. 建立 Session
        var sessionModel = new SessionModel
        {
            LoginUserInfo = new LoginUserInfo
            {
                UserID = user.USER_ID,
                UserName = user.USER_NAME,
                RoleType = user.ROLE_TYPE,
                LoginTime = DateTime.Now
            },
            RoleFuncs = funcs.Select(f => new ClamRoleFunc
            {
                FuncID = f.FUNC_ID,
                FuncName = f.FUNC_NAME,
                ParentID = f.PARENT_ID,
                CanRead = f.CAN_READ == "1",
                CanWrite = f.CAN_WRITE == "1",
                CanDelete = f.CAN_DELETE == "1"
            }).ToList()
        };
        
        Session["SessionModel"] = sessionModel;
        
        // 8. 記錄登入日誌
        _loginDAO.InsertLoginLog(new LoginLog
        {
            USER_ID = user.USER_ID,
            LOGIN_TIME = DateTime.Now,
            LOGIN_IP = GetClientIP(),
            LOGIN_TYPE = "PWD"
        });
        
        return Json(new { success = true, redirectUrl = "/Login/C102M" });
    }
    catch (Exception ex)
    {
        LogUtils.Error("Login Error", ex);
        return Json(new { success = false, message = "登入失敗" });
    }
}
```

### 3.2 密碼加密機制

```mermaid
graph LR
    subgraph "密碼處理流程"
        INPUT[明文密碼] --> SHA512[SHA512 雜湊]
        SHA512 --> HASH[雜湊值]
        HASH --> DB[(資料庫)]
    end
```

```csharp
// Services/CommonsServices.cs
public static string HashSHA512(string input)
{
    using (SHA512 sha512 = SHA512.Create())
    {
        byte[] inputBytes = Encoding.UTF8.GetBytes(input);
        byte[] hashBytes = sha512.ComputeHash(inputBytes);
        
        StringBuilder sb = new StringBuilder();
        foreach (byte b in hashBytes)
        {
            sb.Append(b.ToString("x2"));
        }
        return sb.ToString();
    }
}
```

---

## 4. Session 管理

### 4.1 SessionModel 結構

```mermaid
classDiagram
    class SessionModel {
        +LoginUserInfo UserInfo
        +List~ClamRoleFunc~ RoleFuncs
        +string LastActionFunc
        +string ErrorMessage
        +string ResultMessage
        +ToJson() string
        +FromJson(string json) SessionModel
    }
    
    class LoginUserInfo {
        +string UserID
        +string UserName
        +string IDN
        +string RoleType
        +string HospitalCode
        +DateTime LoginTime
        +string LoginIP
    }
    
    class ClamRoleFunc {
        +string FuncID
        +string FuncName
        +string ParentID
        +int FuncLevel
        +string FuncUrl
        +bool CanRead
        +bool CanWrite
        +bool CanDelete
    }
    
    SessionModel --> LoginUserInfo
    SessionModel --> ClamRoleFunc
```

### 4.2 Session 存取

```csharp
// Models/SessionModel.cs
public class SessionModel
{
    public LoginUserInfo LoginUserInfo { get; set; }
    public List<ClamRoleFunc> RoleFuncs { get; set; }
    public string LastActionFunc { get; set; }
    public string ErrorMessage { get; set; }
    public string ResultMessage { get; set; }
    
    // 序列化為 JSON
    public string ToJson()
    {
        return JsonConvert.SerializeObject(this);
    }
    
    // 從 JSON 還原
    public static SessionModel FromJson(string json)
    {
        return JsonConvert.DeserializeObject<SessionModel>(json);
    }
}

// 存取 Session
public static class SessionHelper
{
    private const string SESSION_KEY = "SessionModel";
    
    public static SessionModel GetSession(HttpSessionStateBase session)
    {
        var json = session[SESSION_KEY] as string;
        if (string.IsNullOrEmpty(json))
            return null;
        return SessionModel.FromJson(json);
    }
    
    public static void SetSession(HttpSessionStateBase session, SessionModel model)
    {
        session[SESSION_KEY] = model.ToJson();
    }
    
    public static void ClearSession(HttpSessionStateBase session)
    {
        session.Remove(SESSION_KEY);
        session.Abandon();
    }
}
```

---

## 5. 授權機制

### 5.1 LoginRequired 篩選器

```mermaid
flowchart TB
    REQUEST[HTTP Request] --> FILTER{LoginRequired}
    
    FILTER --> CHECK_SESSION{檢查 Session}
    CHECK_SESSION -->|不存在| REDIRECT[重導向登入頁]
    CHECK_SESSION -->|存在| CHECK_FUNC{檢查功能權限}
    
    CHECK_FUNC -->|無權限| DENY[存取拒絕]
    CHECK_FUNC -->|有權限| CHECK_PERM{檢查操作權限}
    
    CHECK_PERM -->|讀取| CAN_READ{CanRead?}
    CHECK_PERM -->|寫入| CAN_WRITE{CanWrite?}
    CHECK_PERM -->|刪除| CAN_DELETE{CanDelete?}
    
    CAN_READ -->|是| ALLOW[允許存取]
    CAN_READ -->|否| DENY
    CAN_WRITE -->|是| ALLOW
    CAN_WRITE -->|否| DENY
    CAN_DELETE -->|是| ALLOW
    CAN_DELETE -->|否| DENY
    
    ALLOW --> CONTROLLER[執行 Controller Action]
```

#### LoginRequired 實作

```csharp
// Commons/Filter/LoginRequired.cs
public class LoginRequired : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext filterContext)
    {
        // 檢查是否略過授權
        if (filterContext.ActionDescriptor.IsDefined(typeof(BypassAuthorize), true))
        {
            base.OnActionExecuting(filterContext);
            return;
        }
        
        // 取得 Session
        var session = SessionHelper.GetSession(filterContext.HttpContext.Session);
        
        // 檢查登入狀態
        if (session == null || session.LoginUserInfo == null)
        {
            filterContext.Result = new RedirectResult("/Login/C101M");
            return;
        }
        
        // 取得目前功能 ID
        string areaName = filterContext.RouteData.DataTokens["area"]?.ToString();
        string controllerName = filterContext.RouteData.Values["controller"]?.ToString();
        string actionName = filterContext.RouteData.Values["action"]?.ToString();
        string funcId = $"{areaName}_{controllerName}";
        
        // 檢查功能權限
        var func = session.RoleFuncs.FirstOrDefault(f => f.FuncID == funcId);
        if (func == null)
        {
            filterContext.Result = new RedirectResult("/ErrorPage/AccessDenied");
            return;
        }
        
        // 檢查操作權限
        bool hasPermission = false;
        switch (GetPermissionType(actionName))
        {
            case PermissionType.Read:
                hasPermission = func.CanRead;
                break;
            case PermissionType.Write:
                hasPermission = func.CanWrite;
                break;
            case PermissionType.Delete:
                hasPermission = func.CanDelete;
                break;
        }
        
        if (!hasPermission)
        {
            filterContext.Result = new RedirectResult("/ErrorPage/AccessDenied");
            return;
        }
        
        // 記錄最後操作功能
        session.LastActionFunc = funcId;
        SessionHelper.SetSession(filterContext.HttpContext.Session, session);
        
        base.OnActionExecuting(filterContext);
    }
    
    private PermissionType GetPermissionType(string actionName)
    {
        if (actionName.StartsWith("Delete"))
            return PermissionType.Delete;
        if (actionName.StartsWith("Save") || actionName.StartsWith("New") || 
            actionName.StartsWith("Modify") || actionName.StartsWith("Update"))
            return PermissionType.Write;
        return PermissionType.Read;
    }
}

// 略過授權屬性
public class BypassAuthorize : Attribute { }
```

### 5.2 權限資料表結構

```mermaid
erDiagram
    AMDBUSM ||--o{ AMUROLE : "使用者角色"
    AMROLEM ||--o{ AMUROLE : "角色定義"
    AMROLEM ||--o{ AMGMAPM : "角色功能"
    AMFUNCM ||--o{ AMGMAPM : "功能定義"
    AMGRPM ||--o{ AMGMAPM : "群組定義"
    
    AMDBUSM {
        string USER_ID PK
        string USER_NAME
        string PASSWORD
        string STATUS
        int FAIL_COUNT
    }
    
    AMROLEM {
        string ROLE_ID PK
        string ROLE_NAME
        string ROLE_DESC
    }
    
    AMFUNCM {
        string FUNC_ID PK
        string FUNC_NAME
        string PARENT_ID
        string FUNC_URL
        int FUNC_LEVEL
    }
    
    AMUROLE {
        string USER_ID FK
        string ROLE_ID FK
    }
    
    AMGMAPM {
        string GRP_ID FK
        string FUNC_ID FK
        string CAN_READ
        string CAN_WRITE
        string CAN_DELETE
    }
    
    AMGRPM {
        string GRP_ID PK
        string GRP_NAME
    }
```

---

## 6. 功能選單載入

### 6.1 選單結構

```mermaid
graph TB
    ROOT[根選單] --> L1_1[A1 醫院管理]
    ROOT --> L1_2[A2 案件管理]
    ROOT --> L1_3[A3 帳務管理]
    ROOT --> L1_4[A4 報表統計]
    ROOT --> L1_5[A5 帳號管理]
    ROOT --> L1_6[A6 權限管理]
    ROOT --> L1_7[A7 病歷類型]
    ROOT --> L1_8[A8 系統日誌]
    
    L1_1 --> L2_1[C101M 醫院資料管理]
    L1_1 --> L2_2[C102M 收費標準設定]
    
    L1_6 --> L2_3[C101M 群組管理]
    L1_6 --> L2_4[C102M 角色管理]
    L1_6 --> L2_5[C103M 功能管理]
    L1_6 --> L2_6[C104M 權限設定]
```

### 6.2 選單載入程式

```csharp
// Services/ClamServices.cs
public class ClamServices
{
    /// <summary>
    /// 取得使用者功能選單
    /// </summary>
    public static List<MenuModel> GetUserMenu(string userId)
    {
        var dao = new LoginDAO();
        var funcs = dao.GetUserFunctions(userId);
        
        // 建立選單樹狀結構
        var menuList = new List<MenuModel>();
        var rootFuncs = funcs.Where(f => string.IsNullOrEmpty(f.PARENT_ID));
        
        foreach (var rootFunc in rootFuncs)
        {
            var menu = new MenuModel
            {
                FuncID = rootFunc.FUNC_ID,
                FuncName = rootFunc.FUNC_NAME,
                FuncUrl = rootFunc.FUNC_URL,
                Icon = rootFunc.ICON,
                Children = GetChildMenu(funcs, rootFunc.FUNC_ID)
            };
            menuList.Add(menu);
        }
        
        return menuList;
    }
    
    private static List<MenuModel> GetChildMenu(IEnumerable<FuncModel> funcs, string parentId)
    {
        var children = funcs.Where(f => f.PARENT_ID == parentId);
        return children.Select(f => new MenuModel
        {
            FuncID = f.FUNC_ID,
            FuncName = f.FUNC_NAME,
            FuncUrl = f.FUNC_URL,
            Icon = f.ICON,
            Children = GetChildMenu(funcs, f.FUNC_ID)
        }).ToList();
    }
}
```

---

## 7. 驗證碼 (CAPTCHA)

### 7.1 驗證碼產生

```mermaid
sequenceDiagram
    participant Browser as 瀏覽器
    participant Controller as Controller
    participant Captcha as ValidateCode
    participant Session as Session
    
    Browser->>Controller: GET /Home/GetCaptcha
    Controller->>Captcha: GenerateCode()
    Captcha->>Captcha: 產生隨機字元
    Captcha->>Captcha: 繪製圖片
    Captcha->>Session: 儲存驗證碼
    Captcha-->>Controller: 圖片 Bytes
    Controller-->>Browser: Image Response
```

#### ValidateCode 實作

```csharp
// Commons/ValidateCode.cs
public class ValidateCode
{
    public static byte[] GenerateImage(out string code)
    {
        // 產生隨機碼
        code = GenerateRandomCode(4);
        
        // 建立圖片
        using (var bitmap = new Bitmap(100, 40))
        using (var graphics = Graphics.FromImage(bitmap))
        {
            // 背景
            graphics.Clear(Color.White);
            
            // 干擾線
            Random random = new Random();
            for (int i = 0; i < 5; i++)
            {
                int x1 = random.Next(bitmap.Width);
                int y1 = random.Next(bitmap.Height);
                int x2 = random.Next(bitmap.Width);
                int y2 = random.Next(bitmap.Height);
                graphics.DrawLine(Pens.Silver, x1, y1, x2, y2);
            }
            
            // 繪製文字
            using (var font = new Font("Arial", 18, FontStyle.Bold))
            {
                graphics.DrawString(code, font, Brushes.Navy, 10, 5);
            }
            
            // 輸出
            using (var ms = new MemoryStream())
            {
                bitmap.Save(ms, ImageFormat.Png);
                return ms.ToArray();
            }
        }
    }
    
    private static string GenerateRandomCode(int length)
    {
        const string chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
        var random = new Random();
        return new string(Enumerable.Repeat(chars, length)
            .Select(s => s[random.Next(s.Length)]).ToArray());
    }
}

// Controller
public ActionResult GetCaptcha()
{
    string code;
    var imageBytes = ValidateCode.GenerateImage(out code);
    Session["Captcha"] = code;
    return File(imageBytes, "image/png");
}
```

---

## 8. 安全性考量

### 8.1 密碼政策

```mermaid
graph TB
    subgraph "密碼安全規則"
        A[最小長度 8 字元]
        B[必須包含大小寫字母]
        C[必須包含數字]
        D[不可與前 3 次密碼相同]
        E[90 天強制變更]
    end
```

### 8.2 帳號鎖定機制

| 規則 | 說明 |
|------|------|
| 失敗次數上限 | 5 次 |
| 鎖定時間 | 永久鎖定，需管理員解鎖 |
| 重設方式 | 管理員解鎖或密碼重設 |

### 8.3 Session 安全設定

```xml
<!-- Web.config -->
<system.web>
    <sessionState 
        mode="InProc" 
        timeout="60" 
        cookieless="false"
        regenerateExpiredSessionId="true">
    </sessionState>
    
    <httpCookies 
        httpOnlyCookies="true" 
        requireSSL="true" 
        sameSite="Strict">
    </httpCookies>
</system.web>
```

---

## 9. 登出處理

```csharp
// Controllers/HomeController.cs
public ActionResult Logout()
{
    // 記錄登出日誌
    var session = SessionHelper.GetSession(Session);
    if (session?.LoginUserInfo != null)
    {
        _loginDAO.InsertLogoutLog(new LogoutLog
        {
            USER_ID = session.LoginUserInfo.UserID,
            LOGOUT_TIME = DateTime.Now
        });
    }
    
    // 清除 Session
    SessionHelper.ClearSession(Session);
    
    // 清除認證 Cookie
    FormsAuthentication.SignOut();
    
    return RedirectToAction("Index", "Home");
}
```

---

本文件說明 EECOnline 的身份驗證機制，包含前台民眾的多種驗證方式（自然人憑證、行動憑證、健保卡）與後台管理人員的帳號密碼驗證，以及 Session 管理、授權機制等安全設計。
