# MIT 微笑標章管理系統 - 全端功能詳細範例：報表產生系統

## 功能概述

本文以「MIT 申請書報表產生功能」為例，詳細說明從前端觸發報表產生到後端完成 PDF 文件生成的完整全端開發流程。此功能涵蓋了 Word 模板處理、LibreOffice 文件轉換、PDF 合併、檔案下載等複雜的文件處理機制。

## 系統架構層次

```
前端 Vue.js 應用
    ↓ HTTP API 呼叫（產生報表）
後端 ASP.NET Core API
    ↓ 業務邏輯處理
服務層 (Service Layer)
    ↓ 報表工具呼叫
報表產生工具 (ApplyFormPaperUtil)
    ↓ 模板處理
Word 模板系統 (DocumentFormat.OpenXml)
    ↓ 文件轉換
LibreOffice 轉換引擎
    ↓ PDF 處理
iTextSharp PDF 合併
    ↓ 檔案儲存
檔案系統儲存
    ↓ 檔案下載 API
前端檔案下載處理
```

## 1. 前端報表觸發實作

### 1.1 報表產生按鈕觸發

**檔案位置：** `MITAP2024/mitap2024.client/src/mitf/mit01/MIT0101.vue`

```typescript
// 產生申請書報表的主要函數
// 這個函數負責觸發後端的報表產生流程
const doGenFormReport = (): void => {
  // 第一步：檢查使用者登入狀態
  // 確保使用者已登入才能執行報表產生功能
  if (CommonUtilApi().mitf_CheckIsLogin() == false) {
    return; // 如果未登入，直接返回不執行後續操作
  }

  // 清除之前的警告訊息
  alert_message.value = "";

  // 設定載入狀態為 true，顯示載入動畫給使用者
  loading.value = true;

  // 準備要送到後端的資料物件
  let formdata = {
    jwtkey: SessionApi().getToken(), // JWT Token 用於身份驗證
    guid: applyFormData.guid // 申請表單的唯一識別碼
  };

  // 呼叫後端 API 產生報表
  // 使用封裝好的 mitf_doFetch 函數發送 HTTP 請求
  CommonUtilApi().mitf_doFetch(
    // API 端點：組合根路徑和報表產生的 API 路徑
    CommonUtilApi().rootrul() + "api/mitf/mit01/MIT0101/DoGenFormReport",
    formdata, // 要送出的資料
    afterDoGenFormReport, // 成功時的回調函數
    setAlert // 失敗時的錯誤處理函數
  );
};

// 處理報表產生完成後的回應
// 當後端成功產生報表後，會執行這個函數來下載檔案
const afterDoGenFormReport = (json: any): void => {
  // 將回應資料轉型為 QueryResult 型別
  let rval = json as QueryResult;

  // 關閉載入狀態，隱藏載入動畫
  loading.value = false;

  // 組合 PDF 檔案名稱
  // 使用申請案號作為檔案名稱，確保檔案名稱的唯一性
  let formfile = applyFormData.formId + ".pdf";

  // 呼叫檔案下載函數
  // 參數說明：
  // - applyFormData.formSysId: 申請表單的系統編號
  // - applyFormData.guid: 申請表單的 GUID
  // - 'form': 檔案類型標識
  // - formfile: 要下載的檔案名稱
  CommonUtilApi().downloadFile(
    applyFormData.formSysId,
    applyFormData.guid,
    "form",
    formfile
  );
};
```

**程式碼說明：**

1. **使用者體驗**：先檢查登入狀態，避免未登入使用者執行無效操作
2. **狀態管理**：使用 `loading.value` 提供視覺回饋，讓使用者知道系統正在處理
3. **資料準備**：只傳送必要的資料（JWT Token 和表單 GUID），減少網路傳輸量
4. **回調處理**：使用回調函數模式處理非同步操作，確保操作順序正確
5. **檔案命名**：使用申請案號作為檔案名稱，方便使用者識別和管理

### 1.2 檔案下載機制

**檔案位置：** `MITAP2024/mitap2024.client/src/composables/CommonUtilApi.ts`

```typescript
// 檔案下載的通用函數
// 這個函數封裝了檔案下載的完整邏輯，可被多個組件重複使用
const downloadFile = (
  tid: number | string, // 目標 ID（申請表單的系統編號）
  tGuid: string, // 目標 GUID（申請表單的唯一識別碼）
  tType: string, // 檔案類型（如：'form', 'cert', 'image' 等）
  filename: string // 要下載的檔案名稱
): void => {
  // 準備要送到檔案下載 API 的資料
  const formdata = {
    jwtkey: SessionApi().getToken(), // JWT Token 用於身份驗證
    targetId: tid.toString(), // 轉換為字串格式的目標 ID
    targetGuid: tGuid, // 目標 GUID
    targetType: tType, // 檔案類型標識
    fileName: filename, // 檔案名稱
    fileKey: "" // 檔案金鑰（某些檔案類型需要）
  };

  // 使用 fetch API 發送檔案下載請求
  fetch(CommonUtilApi().rootrul() + "api/COM0105/Downloadfile", {
    method: "POST", // 使用 POST 方法
    headers: { "Content-Type": "application/json" }, // 設定請求標頭
    body: JSON.stringify(formdata) // 將資料轉換為 JSON 字串
  })
    .then((r) => r.blob()) // 將回應轉換為 Blob 物件（二進位資料）
    .then((blob) => {
      // 建立臨時的 URL 物件，用於下載檔案
      const url = window.URL.createObjectURL(blob);

      // 建立隱藏的 <a> 元素用於觸發下載
      const a = document.createElement("a");
      a.href = url; // 設定下載連結
      a.download = filename; // 設定下載檔案名稱

      // 將 <a> 元素加入 DOM，觸發點擊，然後移除
      document.body.appendChild(a);
      a.click(); // 觸發下載
      document.body.removeChild(a);

      // 釋放臨時 URL 物件，避免記憶體洩漏
      window.URL.revokeObjectURL(url);
    });
};
```

**程式碼說明：**

1. **Blob 處理**：使用 `r.blob()` 處理二進位檔案資料，適用於各種檔案格式
2. **臨時 URL**：使用 `createObjectURL` 建立臨時下載連結，避免將大檔案載入記憶體
3. **DOM 操作**：動態建立 `<a>` 元素觸發下載，提供良好的使用者體驗
4. **記憶體管理**：使用 `revokeObjectURL` 釋放資源，防止記憶體洩漏
5. **通用設計**：透過參數化設計，支援不同類型檔案的下載需求

## 2. 後端報表控制器實作

### 2.1 報表產生 API 端點

**檔案位置：** `MITAP2024/MITAP2024.Server/MITF/MIT01/Controller/MIT0101Controller.cs`

```csharp
/// <summary>
/// 產生申請書報表的 API 端點
/// 接收前端請求，驗證身份後呼叫服務層產生 PDF 報表
/// </summary>
[HttpPost("DoGenFormReport")]  // HTTP POST 方法，完整路徑：api/mitf/mit01/MIT0101/DoGenFormReport
public async Task<ActionResult<PagedQueryResult>> DoGenFormReport([FromBody] BaseUpdateModel model)
{
    // 宣告 Session 資料變數，用於存放使用者登入資訊
    MitfSessionDataModel? sessiondata = null;

    // 執行身份驗證和權限檢查
    // 確保只有已登入且有權限的使用者才能產生報表
    var checkResult = _homeService.CheckIsLoginAndAuth(model.jwtkey, ref sessiondata, GetFuncCode());

    if (checkResult == ConstMsg.SUC_CODE_00001)  // 驗證成功
    {
        // 呼叫服務層的報表產生方法
        // 使用 await 確保非同步操作完成後才回傳結果
        return await _service.GenFormReport(model, sessiondata);
    }
    else  // 驗證失敗
    {
        // 回傳錯誤結果給前端
        return new PagedQueryResult()
        {
            jwtkey = model.jwtkey,  // 回傳原始的 JWT Token
            IsSuccess = false,      // 標記操作失敗
            // 根據錯誤類型提供相應的錯誤訊息
            message = checkResult == ConstMsg.ERR_NOTLOGIN ? "請重新登入" : "權限不足"
        };
    }
}
```

**程式碼說明：**

1. **安全驗證**：每個報表產生請求都必須通過身份驗證，確保系統安全
2. **非同步處理**：報表產生是耗時操作，使用 `async/await` 避免阻塞執行緒
3. **統一回應**：使用 `PagedQueryResult` 統一回應格式，便於前端處理
4. **錯誤處理**：明確區分不同類型的錯誤，提供有意義的錯誤訊息
5. **權限控制**：透過功能代碼檢查使用者是否有權限執行此操作

### 2.2 服務層報表產生邏輯

**檔案位置：** `MITAP2024/MITAP2024.Server/MITF/MIT01/Service/MIT0101Service.cs`

```csharp
/// <summary>
/// 產生申請書報表的服務方法
/// 負責呼叫報表工具產生 PDF 檔案
/// </summary>
/// <param name="model">包含申請表單 GUID 的請求模型</param>
/// <param name="sessiondata">使用者 Session 資料</param>
/// <returns>包含操作結果的 PagedQueryResult</returns>
public async Task<ActionResult<PagedQueryResult>> GenFormReport(BaseUpdateModel model, MitfSessionDataModel? sessiondata)
{
    // 使用 Task.Run 將同步操作包裝為非同步操作
    // 這樣可以避免阻塞主執行緒，提高系統效能
    return await Task.Run(() =>
    {
        // 初始化回傳結果物件
        PagedQueryResult result = new PagedQueryResult()
        {
            jwtkey = model.jwtkey,  // 保留原始的 JWT Token
            IsSuccess = false       // 預設為失敗，成功時會被覆寫
        };

        try
        {
            // 呼叫報表產生工具的核心方法
            // ApplyFormPaperUtil.GenApplyFormForA001A005 是報表產生的核心邏輯
            // 參數說明：
            // - _context: 資料庫上下文，用於查詢相關資料
            // - Guid.Parse(model.guid): 將字串格式的 GUID 轉換為 Guid 型別
            // - ref result: 使用參考參數回傳結果，包含成功狀態和檔案路徑
            ApplyFormPaperUtil.GenApplyFormForA001A005(_context, Guid.Parse(model.guid), ref result);
        }
        catch (Exception e)
        {
            // 捕捉任何異常並記錄到日誌
            // TextUtils.GenErrmsgWithNum 會產生包含時間戳記的錯誤訊息
            result.message = TextUtils.GenErrmsgWithNum(logger, "產製申請書失敗", e);
            result.IsSuccess = false;
        }

        // 回傳處理結果
        return result;
    });
}
```

**程式碼說明：**

1. **非同步包裝**：使用 `Task.Run` 將同步的報表產生邏輯包裝為非同步操作
2. **異常處理**：使用 try-catch 捕捉所有可能的異常，確保系統穩定性
3. **日誌記錄**：異常發生時記錄詳細的錯誤資訊，便於問題追蹤和除錯
4. **參考參數**：使用 `ref` 參數讓報表工具直接修改結果物件
5. **資源管理**：透過依賴注入的資料庫上下文確保資源正確管理

## 3. 報表產生核心工具實作

### 3.1 報表產生主流程

**檔案位置：** `MITAP2024/MITAP2024.Server/MITCommon/Utils/ApplyFormPaperUtil.cs`

```csharp
/// <summary>
/// 產生 A001-A005 類型申請書的主要方法
/// 這是整個報表產生系統的核心入口點
/// </summary>
/// <param name="_context">資料庫上下文，用於查詢相關資料</param>
/// <param name="formGuid">申請表單的 GUID</param>
/// <param name="result">回傳結果物件，包含成功狀態和檔案路徑</param>
public static void GenApplyFormForA001A005(MainDbContext _context, Guid formGuid, ref PagedQueryResult result)
{
    // 初始化日誌記錄器
    ILog logger = LogManager.GetLogger(AppSettingReader.GetLoggerName());

    // 第一步：從資料庫查詢申請表單相關資料
    // 查詢申請表單主檔
    var applyform = _context.ApplyForm.Find(formGuid);
    // 查詢申請表單擴充資料
    var applyformext = _context.ApplyFormExt.Find(formGuid);
    // 查詢申請公司資料
    var commain = _context.ComMain.Where(x => x.ComId == applyform.ComId).FirstOrDefault();
    // 查詢申請人資料
    var comman = _context.ComMan.Find(applyform.ComManGuid);
    // 查詢產品分類資料
    var productindustry = _context.ProductIndustry.Find(applyformext.ProductIndustryTypeGuId);
    // 查詢行業分類資料
    var industry = _context.IndustryDetail.Find(productindustry.IndustryGuId);

    // 第二步：設定檔案路徑和工作目錄
    // 取得申請表單的儲存路徑
    string formpath = FormUtils.GetFormPath(_context, applyform.Guid.ToString(), applyform.FormSysId);
    // 建立暫存工作目錄，用於存放處理過程中的臨時檔案
    string worktempPath = Path.Combine(formpath, "temp");
    // 確保暫存目錄存在
    if (!Directory.Exists(worktempPath))
    {
        Directory.CreateDirectory(worktempPath);
    }

    // 第三步：產生申請標題
    // 根據行業分類和申請類型組合申請標題
    string applyTitle = $"{industry.IndustryName} {applyform.FormType}";

    // 第四步：產生各種文件
    // 建立檔案清單，用於存放要合併的文件路徑
    List<string> filelist = new List<string>();
    List<string> addonfilelist = new List<string>();

    // 產生主要申請表單文件
    GetFormDoc(_context, worktempPath, formpath, applyform, applyformext, applyTitle, productindustry, commain, comman, ref filelist, ref addonfilelist);

    // 產生製造商相關文件
    GetFormManuDoc(_context, worktempPath, formpath, applyform, applyformext, applyTitle, productindustry, ref filelist, ref addonfilelist);

    // 產生產品相關文件
    GetFormProductDoc(_context, worktempPath, formpath, applyform, applyformext, applyTitle, productindustry, ref filelist, ref addonfilelist);

    // 第五步：將 Word 文件轉換為 PDF
    List<string> pdffilelist = new List<string>();

    // 轉換主要文件清單
    foreach (string item in filelist)
    {
        logger.Debug("Converting to PDF: " + item);  // 記錄轉換過程
        // 呼叫 LibreOffice 轉換引擎將 Word 文件轉換為 PDF
        pdffilelist.Add(ConvertToPdf(item, worktempPath));
    }

    // 轉換附加文件清單
    foreach (string item in addonfilelist)
    {
        logger.Debug("Converting addon file to PDF: " + item);
        pdffilelist.Add(ConvertToPdf(item, worktempPath));
    }

    // 第六步：合併所有 PDF 檔案
    // 設定最終 PDF 檔案的完整路徑
    string applyformfile = Path.Combine(formpath, $"{applyform.FormId}.PDF");

    // 如果檔案已存在，先刪除舊檔案
    if (File.Exists(applyformfile))
    {
        FileUtils.WipeFile(applyformfile);
    }

    // 使用 iTextSharp 合併多個 PDF 檔案
    iTextSharp.text.Document doc = null;
    PdfCopy copy = null;
    int fileCounter = 0;

    foreach (string item in pdffilelist)
    {
        // 檢查 PDF 檔案是否存在
        if (string.IsNullOrEmpty(item) == false && File.Exists(item))
        {
            // 開啟 PDF 檔案進行讀取
            PdfReader reader = new PdfReader(item);
            PdfReader.unethicalreading = true;  // 允許讀取受保護的 PDF

            // 如果是第一個檔案，建立輸出文件
            if (fileCounter == 0)
            {
                doc = new iTextSharp.text.Document(reader.GetPageSizeWithRotation(1));
                copy = new PdfCopy(doc, new FileStream(applyformfile, FileMode.Create));
                doc.Open();
            }

            // 複製所有頁面到輸出文件
            for (int iPageCnt = 1; iPageCnt <= reader.NumberOfPages; iPageCnt++)
            {
                PdfImportedPage page = copy.GetImportedPage(reader, iPageCnt);
                copy.AddPage(page);
            }

            reader.Close();
            fileCounter++;
        }
    }

    // 關閉 PDF 文件
    if (copy != null)
    {
        copy.Close();
        doc.Close();
    }

    // 第七步：設定回傳結果
    result.Data = applyformfile;  // 回傳最終 PDF 檔案的完整路徑
    result.IsSuccess = true;      // 標記操作成功
}
```

**程式碼說明：**

1. **資料查詢**：一次性查詢所有需要的資料，減少資料庫存取次數
2. **目錄管理**：建立暫存目錄存放處理過程中的臨時檔案
3. **模組化設計**：將不同類型的文件產生分別封裝成獨立方法
4. **檔案轉換**：使用 LibreOffice 將 Word 文件轉換為 PDF 格式
5. **PDF 合併**：使用 iTextSharp 將多個 PDF 檔案合併為單一檔案
6. **資源清理**：適當關閉檔案資源，避免記憶體洩漏
7. **錯誤記錄**：使用日誌記錄處理過程，便於問題追蹤

### 3.2 Word 模板處理機制

**檔案位置：** `MITAP2024/MITAP2024.Server/MITCommon/Utils/ApplyFormPaperUtil.cs`

```csharp
/// <summary>
/// 產生主要申請表單文件的方法
/// 使用 Word 模板和 DocumentFormat.OpenXml 進行文件處理
/// </summary>
/// <param name="_context">資料庫上下文</param>
/// <param name="worktempPath">暫存工作目錄</param>
/// <param name="formpath">表單儲存路徑</param>
/// <param name="applyform">申請表單資料</param>
/// <param name="applyformext">申請表單擴充資料</param>
/// <param name="applyTitle">申請標題</param>
/// <param name="productindustry">產品分類資料</param>
/// <param name="commain">公司資料</param>
/// <param name="comman">申請人資料</param>
/// <param name="filelist">主要檔案清單</param>
/// <param name="addonfilelist">附加檔案清單</param>
private static void GetFormDoc(
    MainDbContext _context,
    string worktempPath,
    string formpath,
    ApplyForm applyform,
    ApplyFormExt applyformext,
    string applyTitle,
    ProductIndustry productindustry,
    ComMain commain,
    ComMan comman,
    ref List<string> filelist,
    ref List<string> addonfilelist)
{
    // 第一步：設定輸出檔案名稱和模板路徑
    // 產生唯一的文件名稱，避免檔案名稱衝突
    var doc1name = applyform.FormId + "_01.docx";

    // 取得 Word 模板檔案的完整路徑
    // 模板檔案存放在 resources/template 目錄下
    var templateFile = Path.Combine(Path.Combine(FormUtils.GetResourcePath(_context), "template"), "A001_01.docx");

    // 設定輸出檔案的完整路徑
    var doc1path = Path.Combine(worktempPath, doc1name);

    // 複製模板檔案到工作目錄，作為處理的基礎
    File.Copy(templateFile, doc1path);

    // 第二步：使用 DocumentFormat.OpenXml 處理 Word 文件
    // 開啟 Word 文件進行編輯
    using (WordprocessingDocument wd = WordprocessingDocument.Open(doc1path, true))
    {
        string xmlString = string.Empty;

        // 讀取文件的 XML 內容
        // Word 文件本質上是 XML 格式，可以直接操作 XML 內容
        using (StreamReader sr = new StreamReader(wd.MainDocumentPart.GetStream()))
        {
            xmlString = sr.ReadToEnd();
        }

        // 第三步：根據申請狀態決定顯示內容
        if (applyform.FormProcess == "T")  // T = 已送審狀態
        {
            // 如果是已送審的申請，顯示實際的申請案號和日期
            xmlString = xmlString.Replace("$1$", TextUtils.EscapeWordXml(applyform.FormId));
            xmlString = xmlString.Replace("$2$", TextUtils.EscapeWordXml(applyform.CreateDate.ToString(ConstFormat.FORMAT_DATE)));
        }
        else
        {
            // 如果是草稿狀態，顯示「預覽」字樣
            xmlString = xmlString.Replace("$1$", TextUtils.EscapeWordXml("預覽"));
            xmlString = xmlString.Replace("$2$", TextUtils.EscapeWordXml("預覽"));
        }

        // 第四步：替換模板中的佔位符號
        // 使用實際資料替換模板中的預設值

        // 替換申請標題
        xmlString = xmlString.Replace("$3$", TextUtils.EscapeWordXml(applyTitle));

        // 替換公司基本資料
        xmlString = xmlString.Replace("$4$", TextUtils.EscapeWordXml(commain.ComName ?? ""));        // 公司名稱
        xmlString = xmlString.Replace("$5$", TextUtils.EscapeWordXml(commain.ComId ?? ""));          // 統一編號
        xmlString = xmlString.Replace("$6$", TextUtils.EscapeWordXml(commain.ComCeo ?? ""));         // 負責人
        xmlString = xmlString.Replace("$7$", TextUtils.EscapeWordXml(commain.ComAddress ?? ""));     // 公司地址
        xmlString = xmlString.Replace("$8$", TextUtils.EscapeWordXml(commain.ComPhone ?? ""));       // 電話號碼
        xmlString = xmlString.Replace("$9$", TextUtils.EscapeWordXml(commain.ComFax ?? ""));         // 傳真號碼

        // 替換申請人資料
        xmlString = xmlString.Replace("$10$", TextUtils.EscapeWordXml(comman.ManName ?? ""));        // 申請人姓名
        xmlString = xmlString.Replace("$11$", TextUtils.EscapeWordXml(comman.ManTitle ?? ""));       // 申請人職稱
        xmlString = xmlString.Replace("$12$", TextUtils.EscapeWordXml(comman.ManPhone ?? ""));       // 申請人電話
        xmlString = xmlString.Replace("$13$", TextUtils.EscapeWordXml(comman.ManMail ?? ""));        // 申請人信箱

        // 替換產品分類資料
        xmlString = xmlString.Replace("$14$", TextUtils.EscapeWordXml(productindustry.ProductIndustryTypeName ?? "")); // 產品分類名稱

        // 第五步：將修改後的 XML 內容寫回文件
        using (StreamWriter sw = new StreamWriter(wd.MainDocumentPart.GetStream(FileMode.Create)))
        {
            sw.Write(xmlString);
            sw.Close();
        }

        // 將處理完成的檔案加入檔案清單
        filelist.Add(doc1path);
    }
}
```

**程式碼說明：**

1. **模板機制**：使用預先設計的 Word 模板，透過佔位符號進行資料替換
2. **XML 操作**：直接操作 Word 文件的 XML 內容，提供最大的彈性
3. **資料轉義**：使用 `TextUtils.EscapeWordXml` 確保特殊字元正確顯示
4. **狀態處理**：根據申請狀態顯示不同內容，支援預覽和正式版本
5. **資源管理**：使用 `using` 語句確保檔案資源正確釋放
6. **檔案管理**：將處理完成的檔案路徑加入清單，供後續處理使用

### 3.3 LibreOffice 文件轉換引擎

```csharp
/// <summary>
/// 將文件轉換為 PDF 格式的核心方法
/// 使用 LibreOffice 的命令列介面進行文件轉換
/// </summary>
/// <param name="sourcepath">來源檔案的完整路徑</param>
/// <param name="outpath">輸出目錄路徑</param>
/// <returns>轉換後的 PDF 檔案完整路徑</returns>
public static string ConvertToPdf(string sourcepath, string outpath)
{
    // 取得來源檔案的副檔名
    var fileext = Path.GetExtension(sourcepath);

    // 設定 PDF 檔案的完整路徑
    var pdfFullPath = sourcepath;
    if (fileext.ToUpper() != ".PDF")
    {
        // 如果不是 PDF 檔案，將副檔名改為 .PDF
        pdfFullPath = sourcepath.Replace(fileext, ".PDF");
    }

    // 檢查來源檔案是否存在
    if (File.Exists(sourcepath))
    {
        // 如果來源檔案不是 PDF 格式，需要進行轉換
        if (fileext.ToUpper() != ".PDF")
        {
            // 檢查是否為 Word 文件格式
            if (fileext.ToUpper() == ".DOCX" || fileext.ToUpper() == ".DOC")
            {
                // 第一步：取得 LibreOffice 執行檔路徑
                // 從設定檔讀取 LibreOffice 的安裝路徑
                string cmd = AppSettingReader.GetOpenOffice();

                // 第二步：組合命令列參數
                // --headless: 無介面模式執行
                // --convert-to pdf: 轉換為 PDF 格式
                // --outdir: 指定輸出目錄
                string cmdparam = $"--headless --convert-to pdf --outdir {outpath} {sourcepath}";

                // 第三步：設定程序啟動資訊
                var processInfo = new ProcessStartInfo(cmd, cmdparam);
                processInfo.CreateNoWindow = false;        // 不建立新視窗
                processInfo.UseShellExecute = false;       // 不使用系統 Shell
                processInfo.RedirectStandardError = true;  // 重新導向錯誤輸出
                processInfo.RedirectStandardOutput = true; // 重新導向標準輸出

                // 第四步：啟動 LibreOffice 轉換程序
                var process = Process.Start(processInfo);
                process.Close();

                // 第五步：等待轉換完成
                // 使用輪詢方式檢查 PDF 檔案是否產生
                bool overtime = false;
                int loop = 0;
                while (!File.Exists(pdfFullPath) && !overtime)
                {
                    System.Threading.Thread.Sleep(1000);  // 等待 1 秒
                    loop++;
                    if (loop > 10)  // 最多等待 10 秒
                    {
                        overtime = true;  // 超時，停止等待
                    }
                }
            }
        }
    }

    // 回傳 PDF 檔案的完整路徑
    return pdfFullPath;
}
```

**程式碼說明：**

1. **格式檢查**：先檢查檔案格式，避免不必要的轉換操作
2. **命令列介面**：使用 LibreOffice 的 headless 模式進行批次轉換
3. **程序管理**：正確設定程序啟動參數，確保轉換程序穩定執行
4. **非同步等待**：使用輪詢方式等待轉換完成，避免阻塞主執行緒
5. **超時處理**：設定最大等待時間，防止程序無限等待
6. **錯誤處理**：重新導向標準輸出和錯誤輸出，便於問題診斷

## 4. 檔案下載控制器實作

### 4.1 檔案下載 API 端點

**檔案位置：** `MITAP2024/MITAP2024.Server/Common/Controller/COM0105Controller.cs`

```csharp
/// <summary>
/// 檔案下載的 API 端點
/// 處理各種類型檔案的下載請求，包含報表、憑證、圖片等
/// </summary>
/// <param name="model">包含下載參數的請求模型</param>
/// <returns>檔案內容或錯誤訊息</returns>
[HttpPost("Downloadfile")]
public async Task<IActionResult> Downloadfile([FromBody] COM0105QueryModel model)
{
    // 設定預設的內容類型
    const string DefaultContentType = "application/octet-stream";

    // 第一步：呼叫服務層取得檔案資訊
    // 服務層會根據檔案類型和參數找到實際的檔案路徑
    var queryResult = _service.Downloadfile(model);

    if (queryResult.IsSuccess)  // 成功取得檔案資訊
    {
        // 第二步：取得檔案的完整路徑
        var filePath = ((COM0105Model)queryResult.Data).FileName;
        string fileName = Path.GetFileName(filePath);

        // 第三步：判斷檔案的 MIME 類型
        string contentType = "";
        // 使用 FileExtensionContentTypeProvider 根據副檔名判斷內容類型
        if (!_fileExtensionContentTypeProvider.TryGetContentType(filePath, out contentType))
        {
            // 如果無法判斷，使用預設的內容類型
            contentType = DefaultContentType;
        }

        // 第四步：讀取檔案內容並建立回應
        var result = new FileContentResult(System.IO.File.ReadAllBytes(filePath), contentType)
        {
            // 設定下載檔案名稱，瀏覽器會使用這個名稱儲存檔案
            FileDownloadName = Path.GetFileName(filePath)
        };

        return result;
    }
    else  // 取得檔案資訊失敗
    {
        // 回傳錯誤訊息
        var contentType = "text/html";
        var result = new FileContentResult(Encoding.ASCII.GetBytes(queryResult.message.ToString()), contentType)
        {
            FileDownloadName = Path.GetFileName(queryResult.message)
        };

        return result;
    }
}
```

**程式碼說明：**

1. **統一介面**：提供統一的檔案下載介面，支援多種檔案類型
2. **MIME 類型**：自動判斷檔案的 MIME 類型，確保瀏覽器正確處理
3. **檔案讀取**：使用 `File.ReadAllBytes` 一次性讀取檔案內容
4. **錯誤處理**：當檔案不存在或權限不足時，回傳適當的錯誤訊息
5. **檔案名稱**：設定正確的下載檔案名稱，提供良好的使用者體驗

### 4.2 檔案下載服務層邏輯

**檔案位置：** `MITAP2024/MITAP2024.Server/Common/Service/COM0105Service.cs`

```csharp
/// <summary>
/// 檔案下載的服務層方法
/// 根據檔案類型和參數找到實際的檔案路徑
/// </summary>
/// <param name="model">下載請求參數</param>
/// <returns>包含檔案路徑的結果物件</returns>
public PagedQueryResult Downloadfile(COM0105QueryModel model)
{
    // 初始化回傳結果
    PagedQueryResult result = new PagedQueryResult()
    {
        TotalCount = 0,
        Data = new COM0105Model(),
        IsSuccess = false
    };

    // 第一步：驗證必要參數
    if (string.IsNullOrEmpty(model.targetType))
    {
        result.message = TextUtils.AppendMessageWithComma(result.message, "未傳入要下載的檔案類型");
        result.IsSuccess = false;
    }
    if (string.IsNullOrEmpty(model.fileName))
    {
        result.message = TextUtils.AppendMessageWithComma(result.message, "未傳入要下載的檔案名稱");
        result.IsSuccess = false;
    }

    // 如果參數驗證失敗，直接回傳錯誤
    if (!result.IsSuccess)
    {
        return result;
    }

    // 第二步：根據檔案類型決定檔案路徑
    switch (model.targetType.ToLower())
    {
        case "form":  // 申請表單類型
            ApplyForm applyForm = null;

            if (string.IsNullOrEmpty(model.targetId))
            {
                // 如果沒有提供 targetId，使用 GUID 查詢
                applyForm = _context.ApplyForm.Find(Guid.Parse(model.targetGuid));
                if (applyForm != null)
                {
                    // 組合檔案的完整路徑
                    ((COM0105Model)result.Data).FileName = Path.Combine(
                        FormUtils.GetFormPath(_context, model.targetGuid, applyForm.FormSysId),
                        model.fileName
                    );
                    result.IsSuccess = true;
                }
            }
            else
            {
                // 如果有提供 targetId，直接使用
                ((COM0105Model)result.Data).FileName = Path.Combine(
                    FormUtils.GetFormPath(_context, model.targetGuid, model.targetId),
                    model.fileName
                );
                result.IsSuccess = true;
            }
            break;

        case "cert":  // 憑證檔案類型
            // 處理憑證檔案的路徑邏輯
            // ... 其他憑證處理邏輯
            break;

        case "image":  // 圖片檔案類型
            // 處理圖片檔案的路徑邏輯
            // ... 其他圖片處理邏輯
            break;

        default:
            result.message = "不支援的檔案類型";
            result.IsSuccess = false;
            break;
    }

    return result;
}
```

**程式碼說明：**

1. **參數驗證**：確保所有必要參數都已提供，避免後續處理錯誤
2. **類型分派**：根據檔案類型使用不同的路徑解析邏輯
3. **路徑組合**：使用工具類別組合正確的檔案路徑
4. **彈性設計**：支援多種參數組合，適應不同的使用情境
5. **錯誤回饋**：提供明確的錯誤訊息，便於問題診斷

## 5. 完整資料流程圖

```
報表產生完整流程：

前端操作流程：
1. 使用者點擊「產生申請書」按鈕
2. 前端檢查登入狀態
3. 顯示載入動畫
4. 呼叫 API：POST /api/mitf/mit01/MIT0101/DoGenFormReport

後端報表產生流程：
5. 控制器接收請求
6. 驗證 JWT Token 與權限
7. 呼叫服務層 GenFormReport 方法
8. 服務層呼叫 ApplyFormPaperUtil.GenApplyFormForA001A005

報表工具處理流程：
9. 查詢申請表單相關資料（申請表單、公司、申請人、產品分類）
10. 建立暫存工作目錄
11. 複製 Word 模板檔案
12. 使用 DocumentFormat.OpenXml 處理模板
    - 讀取 XML 內容
    - 替換佔位符號
    - 寫回修改後的內容
13. 呼叫 LibreOffice 轉換 Word 為 PDF
    - 執行命令列轉換
    - 等待轉換完成
14. 使用 iTextSharp 合併多個 PDF 檔案
    - 讀取各個 PDF 檔案
    - 複製所有頁面
    - 產生最終合併檔案
15. 清理暫存檔案
16. 回傳成功結果

前端檔案下載流程：
17. 接收 API 回應
18. 關閉載入動畫
19. 組合檔案名稱
20. 呼叫 downloadFile 函數
21. 發送檔案下載請求：POST /api/COM0105/Downloadfile

後端檔案下載流程：
22. COM0105Controller 接收下載請求
23. 呼叫服務層 Downloadfile 方法
24. 根據檔案類型解析檔案路徑
25. 檢查檔案是否存在
26. 判斷檔案 MIME 類型
27. 讀取檔案內容
28. 回傳檔案資料

前端檔案處理流程：
29. 接收檔案 Blob 資料
30. 建立臨時 URL
31. 建立隱藏的下載連結
32. 觸發檔案下載
33. 清理臨時資源
```

## 6. 錯誤處理與日誌記錄

### 6.1 報表產生錯誤處理

```csharp
// 在服務層中的錯誤處理範例
try
{
    ApplyFormPaperUtil.GenApplyFormForA001A005(_context, Guid.Parse(model.guid), ref result);
}
catch (Exception e)
{
    // 產生包含時間戳記的錯誤訊息
    result.message = TextUtils.GenErrmsgWithNum(logger, "產製申請書失敗", e);
    result.IsSuccess = false;

    // 記錄詳細的錯誤資訊到日誌
    logger.Error($"報表產生失敗 - 申請表單GUID: {model.guid}", e);
}
```

### 6.2 LibreOffice 轉換錯誤處理

```csharp
// 在 ConvertToPdf 方法中的錯誤處理
if (loop > 10)  // 轉換超時
{
    logger.Warn($"LibreOffice 轉換超時 - 來源檔案: {sourcepath}");
    // 可以考慮回傳原始檔案或預設的錯誤 PDF
}

// 檢查轉換結果
if (!File.Exists(pdfFullPath))
{
    logger.Error($"PDF 轉換失敗 - 預期檔案: {pdfFullPath}");
    // 回傳空字串或拋出異常
}
```

**程式碼說明：**

1. **分層錯誤處理**：在不同層級捕捉和處理錯誤，確保系統穩定性
2. **詳細日誌**：記錄足夠的上下文資訊，便於問題追蹤和除錯
3. **使用者友善**：向使用者提供有意義的錯誤訊息，避免技術細節
4. **超時處理**：對於可能長時間執行的操作設定合理的超時時間
5. **資源清理**：確保在錯誤情況下也能正確清理暫存檔案和資源

## 7. 開發與維護指南

### 7.1 新增報表類型的步驟

當需要新增不同類型的申請書報表時，可以按照以下步驟進行：

1. **建立新的模板檔案**

   ```
   - 在 resources/template 目錄下建立新的 Word 模板
   - 使用 $1$, $2$, $3$ 等佔位符號標記要替換的內容
   - 確保模板格式符合業務需求
   ```

2. **擴展 ApplyFormPaperUtil 類別**

   ```csharp
   // 新增對應的報表產生方法
   public static void GenApplyFormForA006(MainDbContext _context, Guid formGuid, ref PagedQueryResult result)
   {
       // 實作新類型的報表產生邏輯
       // 參考現有的 GenApplyFormForA001A005 方法
   }
   ```

3. **更新服務層方法**

   ```csharp
   // 在對應的服務類別中新增或修改 GenFormReport 方法
   public async Task<ActionResult<PagedQueryResult>> GenFormReport(BaseUpdateModel model, MitfSessionDataModel? sessiondata)
   {
       // 根據申請類型呼叫對應的報表產生方法
       switch (申請類型)
       {
           case "A006":
               ApplyFormPaperUtil.GenApplyFormForA006(_context, Guid.Parse(model.guid), ref result);
               break;
           // ... 其他類型
       }
   }
   ```

4. **測試新的報表功能**
   - 建立測試資料
   - 驗證模板替換是否正確
   - 確認 PDF 轉換和合併功能正常
   - 測試檔案下載功能

### 7.2 效能優化建議

1. **暫存檔案管理**

   ```csharp
   // 定期清理暫存檔案，避免磁碟空間不足
   public static void CleanupTempFiles(string tempPath, int daysOld = 7)
   {
       var cutoffDate = DateTime.Now.AddDays(-daysOld);
       var files = Directory.GetFiles(tempPath, "*", SearchOption.AllDirectories);

       foreach (var file in files)
       {
           var fileInfo = new FileInfo(file);
           if (fileInfo.CreationTime < cutoffDate)
           {
               File.Delete(file);
           }
       }
   }
   ```

2. **非同步處理優化**

   ```csharp
   // 對於大量報表產生需求，考慮使用背景工作佇列
   public async Task<string> QueueReportGeneration(Guid formGuid)
   {
       var jobId = Guid.NewGuid().ToString();

       // 將報表產生工作加入佇列
       _backgroundTaskQueue.QueueBackgroundWorkItem(async token =>
       {
           await GenerateReportAsync(formGuid, jobId);
       });

       return jobId;
   }
   ```

3. **快取機制**
   ```csharp
   // 對於相同內容的報表，可以考慮快取機制
   public string GetCachedReportPath(string cacheKey)
   {
       var cachedPath = _cache.Get<string>(cacheKey);
       if (!string.IsNullOrEmpty(cachedPath) && File.Exists(cachedPath))
       {
           return cachedPath;
       }
       return null;
   }
   ```

### 7.3 故障排除指南

1. **LibreOffice 轉換問題**

   ```
   問題：PDF 轉換失敗或超時
   解決方案：
   - 檢查 LibreOffice 是否正確安裝
   - 確認 appsettings.json 中的路徑設定正確
   - 檢查系統權限是否允許執行 LibreOffice
   - 增加轉換超時時間
   ```

2. **模板處理問題**

   ```
   問題：佔位符號未正確替換
   解決方案：
   - 檢查模板檔案中的佔位符號格式
   - 確認 TextUtils.EscapeWordXml 正確處理特殊字元
   - 驗證資料庫查詢結果是否正確
   ```

3. **PDF 合併問題**
   ```
   問題：PDF 合併失敗或檔案損壞
   解決方案：
   - 檢查來源 PDF 檔案是否有效
   - 確認 iTextSharp 版本相容性
   - 檢查檔案權限和磁碟空間
   ```

### 7.4 監控與日誌

1. **關鍵指標監控**

   ```csharp
   // 記錄報表產生的關鍵指標
   public void LogReportMetrics(string reportType, TimeSpan duration, bool success)
   {
       logger.Info($"報表產生統計 - 類型: {reportType}, 耗時: {duration.TotalSeconds}秒, 成功: {success}");

       // 可以整合到監控系統中
       _metricsCollector.RecordReportGeneration(reportType, duration, success);
   }
   ```

2. **詳細日誌記錄**
   ```csharp
   // 在關鍵步驟記錄詳細資訊
   logger.Debug($"開始處理申請表單 - GUID: {formGuid}");
   logger.Debug($"模板檔案路徑: {templateFile}");
   logger.Debug($"輸出檔案路徑: {outputFile}");
   logger.Debug($"LibreOffice 轉換命令: {cmd} {cmdparam}");
   ```

### 7.5 安全性考量

1. **檔案路徑驗證**

   ```csharp
   // 防止路徑遍歷攻擊
   public bool IsValidFilePath(string filePath, string allowedDirectory)
   {
       var fullPath = Path.GetFullPath(filePath);
       var allowedPath = Path.GetFullPath(allowedDirectory);

       return fullPath.StartsWith(allowedPath);
   }
   ```

2. **檔案類型檢查**

   ```csharp
   // 限制允許下載的檔案類型
   private readonly string[] AllowedExtensions = { ".pdf", ".docx", ".jpg", ".png" };

   public bool IsAllowedFileType(string fileName)
   {
       var extension = Path.GetExtension(fileName).ToLower();
       return AllowedExtensions.Contains(extension);
   }
   ```

3. **權限控制**
   ```csharp
   // 確保使用者只能下載自己的檔案
   public bool CanUserAccessFile(string userId, string fileGuid)
   {
       var applyForm = _context.ApplyForm.Find(Guid.Parse(fileGuid));
       return applyForm?.ComId == GetUserCompanyId(userId);
   }
   ```

這個報表產生系統展示了完整的文件處理流程，從前端使用者觸發到後端複雜的文件處理，涵蓋了模板處理、格式轉換、檔案合併、下載機制等各個面向。透過詳細的程式碼說明和開發指南，團隊成員可以深入了解系統的運作原理，並能夠有效地維護和擴展報表功能。
