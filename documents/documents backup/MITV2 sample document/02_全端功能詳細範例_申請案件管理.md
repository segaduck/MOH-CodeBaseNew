# MIT 微笑標章管理系統 - 全端功能詳細範例：申請案件管理

## 功能概述

本文以「MIT 申請案件管理功能（MIT0101）」為例，詳細說明從前端到後端的完整全端開發流程。此功能涵蓋了申請案件的建立、編輯、送審、報表產生等完整業務流程。

## 系統架構層次

```
前端 Vue.js 應用
    ↓ HTTP API 呼叫
後端 ASP.NET Core API
    ↓ 業務邏輯處理
服務層 (Service Layer)
    ↓ 資料存取
資料存取層 (Entity Framework)
    ↓ 資料庫操作
SQL Server 資料庫
```

## 1. 前端實作詳解

### 1.1 Vue 組件結構

**檔案位置：** `MITAP2024/mitap2024.client/src/mitf/mit01/MIT0101.vue`

```typescript
// 主要組件結構
<template>
    <!-- 主容器：使用 Bootstrap 的 container-fluid 類別提供全寬度佈局 -->
    <div class="container-flud">
        <!-- 頁面標題組件：顯示當前功能的標題 -->
        <PageTitle :title="'標章申請(MIT0101)'" />

        <!-- 條件式顯示案件編號：只有當申請表單已有編號時才顯示 -->
        <!-- v-if="applyFormData.formId" 表示只有當 formId 有值時才渲染此元素 -->
        <div v-if="applyFormData.formId" class="alert alert-info">
            <span class="fw-bold text-primary">案件編號:</span>{{ applyFormData.formId }}
        </div>
    </div>

    <!-- 申請表單編輯區組件 -->
    <!-- 這是一個子組件，負責處理申請表單的編輯功能 -->
    <ApplyFormEdit
        :applyform-data="applyFormData"      <!-- 傳入申請表單資料 -->
        :productIndustry="productIndustryData" <!-- 傳入產品分類資料 -->
        :formnote="formnote"                 <!-- 傳入表單備註資料 -->
        @update:applyform-data="handleApplyFormUpdate"  <!-- 監聽申請表單資料更新事件 -->
        @update:product-industry="handleProductIndustry" <!-- 監聽產品分類更新事件 -->
        @update:formnote="handleFormNote"    <!-- 監聽備註更新事件 -->
        :formtype="'a001'" />                <!-- 指定表單類型為 a001（新申請） -->

    <!-- 製造商列表組件 -->
    <!-- v-if 確保只有在申請表單已建立（有 formId）時才顯示 -->
    <FormManuList
        v-if="applyFormData.formId"          <!-- 條件式渲染：只有申請表單存在時才顯示 -->
        :applyform="applyFormData"           <!-- 傳入申請表單資料 -->
        :productIndustry="productIndustryData" <!-- 傳入產品分類資料 -->
        :formtype="'a001'"                   <!-- 指定表單類型 -->
        :formnote="formnote" />              <!-- 傳入備註資料 -->

    <!-- 產品列表組件 -->
    <!-- 負責顯示和管理申請的產品項目 -->
    <FormProductList
        v-if="applyFormData.formId"          <!-- 條件式渲染：確保申請表單已存在 -->
        :applyform="applyFormData"           <!-- 傳入申請表單資料 -->
        :productIndustry="productIndustryData" <!-- 傳入產品分類資料 -->
        :formtype="'a001'" />                <!-- 指定表單類型 -->
</template>
```

**程式碼說明：**

1. **模板結構**：使用 Vue 3 的 `<template>` 標籤定義組件的 HTML 結構
2. **條件式渲染**：`v-if` 指令用於根據條件決定是否渲染元素，避免在資料未準備好時顯示空白內容
3. **屬性綁定**：`:title` 是 `v-bind:title` 的簡寫，用於將 JavaScript 表達式綁定到 HTML 屬性
4. **事件監聽**：`@update:xxx` 是 `v-on:update:xxx` 的簡寫，用於監聽子組件發出的自定義事件
5. **組件通信**：透過 props（屬性）向下傳遞資料，透過 events（事件）向上傳遞資料變更

### 1.2 資料模型定義

```typescript
// 申請表單資料介面定義
// 這個介面定義了申請表單在前端的資料結構
interface ApplyFormData {
  guid: string; // 申請表單的唯一識別碼（GUID 格式）
  formId: string; // 申請案號（系統自動產生，如：A001240001）
  formType: string; // 申請作業代碼（a001=新申請, a002=補換發, a003=自行印製等）
  comId: string; // 申請公司的統一編號（8位數字）
  formProcess: string; // 案件處理狀態（D=草稿, T=送審中, P=審核通過, R=退件等）
  certtype: number; // 憑證類型（1=憑證簽章, 2=紙本用印）
  certdata: string; // 憑證資料（存放憑證相關資訊的 JSON 字串）
  // ... 其他欄位如建立時間、修改時間、申請人資訊等
}

// 產品分類資料介面定義
// 定義產品所屬的行業分類資訊
interface ProductIndustryData {
  guid: string; // 產品分類的唯一識別碼
  industryGuId: string; // 主分類的 GUID（如：紡織品、食品、電子產品等）
  productIndustryTypeGuId: string; // 次分類的 GUID（如：紡織品下的成衣、家飾用品等）
  // ... 其他欄位如分類名稱、代碼、審查單位等
}
```

**程式碼說明：**

1. **TypeScript 介面**：使用 `interface` 關鍵字定義資料結構，提供型別檢查和 IDE 智能提示
2. **GUID 欄位**：`guid` 欄位使用字串型別存放 GUID，這是後端資料庫的主鍵
3. **狀態管理**：`formProcess` 欄位用於追蹤申請案件的處理狀態，前端根據此狀態決定可執行的操作
4. **憑證處理**：`certtype` 和 `certdata` 用於處理不同的憑證簽章方式
5. **分類關聯**：產品分類採用階層式結構，主分類和次分類透過 GUID 建立關聯

### 1.3 核心業務邏輯

```typescript
// 送出申請案件的主要函數
// 這個函數負責驗證使用者同意條款並送出申請案件到後端
const doSubmit = () => {
  // 檢查使用者是否已同意切結事項
  // aggree.value 是一個響應式變數，"1" 表示已同意
  if (aggree.value != "1") {
    // 如果未同意，顯示警告訊息並中止執行
    setAlert("您必須同意切結事項才可進行下一步驟!");
  } else {
    // 準備要送到後端的資料物件
    let formdata = {
      jwtkey: SessionApi().getToken(), // 從 Session 取得 JWT Token 用於身份驗證
      guid: applyFormData.guid, // 申請表單的唯一識別碼
      q_startRow: 0, // 查詢起始列（分頁用，這裡不需要所以設為 0）
      q_readRow: 0, // 查詢讀取列數（分頁用，這裡不需要所以設為 0）
      showList: false, // 是否顯示列表（UI 狀態控制）
      showEdit: false, // 是否顯示編輯區（UI 狀態控制）
      certtype: applyFormData.certtype, // 憑證類型（1=憑證簽章, 2=紙本用印）
      certdata: applyFormData.certdata // 憑證資料（JSON 字串格式）
    };

    // 設定載入狀態為 true，顯示載入動畫
    loading.value = true;

    // 呼叫 API 送出申請案件
    CommonUtilApi().mitf_doFetch(
      // API 端點 URL：組合根路徑和 API 路徑
      CommonUtilApi().rootrul() + "api/mitf/mit01/MIT0101/DoSendForm",
      formdata, // 要送出的資料
      afterDoSubmit, // 成功時的回調函數
      setAlert // 失敗時的錯誤處理函數
    );
  }
};

// 處理 API 回應的回調函數
// 當後端成功處理申請案件送出請求後，會執行這個函數
const afterDoSubmit = (json: any): void => {
  // 將回應資料轉型為 QueryResult 型別
  let rval = json as QueryResult;

  // 關閉載入狀態
  loading.value = false;

  // 根據憑證類型顯示不同的成功訊息
  if (applyFormData.certtype == 1) {
    // 憑證簽章：直接完成送出，不需要額外步驟
    alert("您的提交申請案號為:" + rval.data + "...");
  } else {
    // 紙本用印：需要下載申請書並上傳用印後的文件
    alert(
      "您的提交申請案號為:" +
        rval.data +
        "\n請優先至列表下載申請書，列印出第1頁用印上傳..."
    );
  }

  // 跳轉到案件列表頁面，讓使用者查看已送出的申請案件
  let urlstr = CommonUtilApi().rootrul() + "mitf/mit02/mit0201";
  window.open(urlstr, "_self"); // '_self' 表示在同一個視窗開啟
};
```

**程式碼說明：**

1. **條件檢查**：在送出前先檢查使用者是否同意條款，這是業務邏輯的必要驗證
2. **資料準備**：組織要送到後端的資料，包含身份驗證 Token 和業務資料
3. **非同步處理**：使用回調函數處理 API 回應，避免阻塞使用者介面
4. **狀態管理**：透過 `loading.value` 控制載入動畫的顯示/隱藏
5. **使用者體驗**：根據不同的憑證類型提供相應的指導訊息
6. **頁面導航**：完成操作後自動跳轉到相關頁面，提供流暢的使用體驗

### 1.4 API 呼叫機制

```typescript
// CommonUtilApi.ts 中的 API 呼叫封裝函數
// 這個函數封裝了前端與後端 API 的通信邏輯
const mitf_doFetch = (
  url: string, // API 端點的完整 URL
  formdata: any, // 要送到後端的資料物件
  successCallback: Function, // 成功時的回調函數
  errorCallback: Function // 失敗時的錯誤處理函數
) => {
  // 使用瀏覽器原生的 fetch API 發送 HTTP 請求
  fetch(url, {
    method: "post", // 使用 POST 方法
    headers: { "Content-Type": "application/json" }, // 設定內容類型為 JSON
    body: JSON.stringify(formdata) // 將 JavaScript 物件轉換為 JSON 字串
  })
    .then((r) => r.json()) // 將回應轉換為 JSON 物件
    .then((json) => {
      // 檢查後端回應是否成功
      if (mitf_DealFetchFailMsg(json)) {
        // 如果成功，執行成功回調函數
        successCallback(json);
      }
      // 如果失敗，mitf_DealFetchFailMsg 函數會處理錯誤訊息
    })
    .catch((err) => {
      // 捕捉網路錯誤或其他異常
      errorCallback("網路錯誤: " + err);
    });
};

// 錯誤處理函數
// 統一處理後端 API 回應的錯誤狀況
const mitf_DealFetchFailMsg = (json: any): boolean => {
  // 檢查回應是否為空或無效
  if (typeof json === "undefined" || json === null) {
    alert("系統錯誤，請聯絡管理員");
    return false;
  }

  // 檢查業務邏輯是否成功
  if (json.isSuccess === false) {
    // 特殊處理：登入逾時
    if (json.message === ConstMsg().ERR_NOTLOGIN) {
      alert("登入逾時，請重新登入");
      SessionApi().removeSessionData(); // 清除本地 Session 資料
      router.push("/mitf/login"); // 跳轉到登入頁面
      return false;
    } else {
      // 一般錯誤：顯示後端回傳的錯誤訊息
      alert(json.message || "操作失敗");
      return false;
    }
  }

  // 成功：回傳 true 讓呼叫端繼續處理
  return true;
};
```

**程式碼說明：**

1. **封裝設計**：將 HTTP 請求邏輯封裝成可重用的函數，避免重複程式碼
2. **Promise 鏈**：使用 `.then()` 鏈式處理非同步操作，確保按順序執行
3. **錯誤分層**：區分網路錯誤和業務邏輯錯誤，提供不同的處理方式
4. **統一格式**：所有 API 請求都使用 JSON 格式，確保前後端資料交換的一致性
5. **使用者體驗**：自動處理登入逾時，無需使用者手動重新登入
6. **錯誤回饋**：提供明確的錯誤訊息，幫助使用者了解問題所在

## 2. 後端 API 控制器實作

### 2.1 控制器結構

**檔案位置：** `MITAP2024/MITAP2024.Server/MITF/MIT01/Controller/MIT0101Controller.cs`

```csharp
// 定義 API 路由和控制器類別
// [Route] 屬性定義了此控制器的基礎路由路徑
[Route("api/mitf/mit01/[controller]")]  // 實際路由為：api/mitf/mit01/MIT0101
[ApiController]                         // 標記為 API 控制器，啟用自動模型驗證等功能
public class MIT0101Controller : ControllerBase
{
    // 依賴注入的服務物件
    // 業務邏輯服務：處理申請案件相關的業務邏輯
    private IMIT0101Service _service { get; set; }

    // 首頁服務：處理身份驗證和權限檢查
    private MITAP2024.Server.MITF.HOME.Service.IHomeService _homeService { get; set; }

    // 建構函數：透過依賴注入取得所需的服務
    public MIT0101Controller(
        IMIT0101Service service,                                    // 注入業務邏輯服務
        MITAP2024.Server.MITF.HOME.Service.IHomeService homeService // 注入身份驗證服務
    )
    {
        _service = service;         // 儲存業務邏輯服務參考
        _homeService = homeService; // 儲存身份驗證服務參考
    }

    /// <summary>
    /// 送出申請案件的 API 端點
    /// 處理前端送出的申請案件資料，進行身份驗證後交由服務層處理
    /// </summary>
    [HttpPost("DoSendForm")]  // HTTP POST 方法，完整路徑：api/mitf/mit01/MIT0101/DoSendForm
    public async Task<ActionResult<PagedQueryResult>> DoSendForm([FromBody] MIT0102QueryModel model)
    {
        // 宣告 Session 資料變數，用於存放使用者登入資訊
        MitfSessionDataModel? sessiondata = null;

        // 檢查使用者是否已登入且有權限執行此功能
        // 傳入 JWT Token、Session 資料參考、功能代碼
        var checkResult = _homeService.CheckIsLoginAndAuth(model.jwtkey, ref sessiondata, GetFuncCode());

        // 檢查驗證結果
        if (checkResult == ConstMsg.SUC_CODE_00001)  // 驗證成功
        {
            // 呼叫服務層處理申請案件送出邏輯
            return await _service.SendForm(model, sessiondata);
        }
        else  // 驗證失敗
        {
            // 回傳錯誤結果
            return new PagedQueryResult()
            {
                jwtkey = model.jwtkey,  // 回傳原始的 JWT Token
                IsSuccess = false,      // 標記操作失敗
                // 根據錯誤類型回傳不同的錯誤訊息
                message = checkResult == ConstMsg.ERR_NOTLOGIN ? "請重新登入" : "權限不足"
            };
        }
    }

    /// <summary>
    /// 產生申請書報表的 API 端點
    /// 根據申請案件資料產生 PDF 格式的申請書
    /// </summary>
    [HttpPost("DoGenFormReport")]  // HTTP POST 方法，完整路徑：api/mitf/mit01/MIT0101/DoGenFormReport
    public async Task<ActionResult<PagedQueryResult>> DoGenFormReport([FromBody] BaseUpdateModel model)
    {
        // 宣告 Session 資料變數
        MitfSessionDataModel? sessiondata = null;

        // 執行身份驗證和權限檢查
        var checkResult = _homeService.CheckIsLoginAndAuth(model.jwtkey, ref sessiondata, GetFuncCode());

        if (checkResult == ConstMsg.SUC_CODE_00001)  // 驗證成功
        {
            // 呼叫服務層產生報表
            return await _service.GenFormReport(model, sessiondata);
        }
        else  // 驗證失敗
        {
            // 回傳錯誤結果
            return new PagedQueryResult()
            {
                jwtkey = model.jwtkey,
                IsSuccess = false,
                message = checkResult == ConstMsg.ERR_NOTLOGIN ? "請重新登入" : "權限不足"
            };
        }
    }

    // 私有方法：取得當前功能的代碼
    // 用於權限檢查，每個控制器都有對應的功能代碼
    private string GetFuncCode()
    {
        return "MIT0101";  // 申請案件管理功能的代碼
    }
}
```

**程式碼說明：**

1. **MVC 架構**：控制器負責接收 HTTP 請求，處理輸入驗證，呼叫業務邏輯，回傳結果
2. **依賴注入**：透過建構函數注入所需的服務，提高程式碼的可測試性和可維護性
3. **身份驗證**：每個 API 端點都先檢查使用者身份和權限，確保安全性
4. **非同步處理**：使用 `async/await` 處理可能耗時的操作，避免阻塞執行緒
5. **統一回應格式**：所有 API 都回傳 `PagedQueryResult` 格式，確保前端處理的一致性
6. **錯誤處理**：區分不同類型的錯誤（未登入、權限不足），提供適當的錯誤訊息

### 2.2 身份驗證與授權機制

```csharp
// HomeService.cs 中的身份驗證邏輯
// 這個方法結合了登入檢查和權限驗證，是系統安全的核心機制
public string CheckIsLoginAndAuth(
    string? jwtkey,                      // 前端傳來的 JWT Token
    ref MitfSessionDataModel? sessiondata, // 用於回傳 Session 資料的參考參數
    string funcCode                      // 功能代碼，用於權限檢查
)
{
    // 第一步：檢查使用者是否已登入
    // 透過 JWT Token 驗證使用者身份並取得 Session 資料
    if (CheckIsLogin(jwtkey, ref sessiondata) == false)
    {
        // 如果未登入，回傳登入錯誤代碼
        return ConstMsg.ERR_NOTLOGIN;
    }
    else
    {
        // 第二步：檢查使用者是否有權限執行此功能
        // 根據功能代碼和使用者的角色權限進行檢查
        if (CheckFuncAuth(funcCode, sessiondata) == true)
        {
            // 身份和權限都驗證通過，回傳成功代碼
            return ConstMsg.SUC_CODE_00001;
        }
        else
        {
            // 已登入但權限不足，回傳權限錯誤代碼
            return ConstMsg.ERR_CODE_90002;
        }
    }
}

// 檢查使用者登入狀態的核心方法
// 透過 JWT Token 從 Redis 快取中取得使用者的 Session 資料
public bool CheckIsLogin(
    string? jwtkey,                      // JWT Token
    ref MitfSessionDataModel? sessiondata // 用於回傳 Session 資料
)
{
    // 檢查 JWT Token 是否為空
    if (string.IsNullOrEmpty(jwtkey))
    {
        return false;  // Token 為空，視為未登入
    }

    // 從 Redis 快取中取得 Session 資料
    // SessionManager.GetMitfSessionData 會根據 JWT Token 查詢對應的 Session
    var sessionmodel = SessionManager.GetMitfSessionData(jwtkey);

    // 檢查是否成功取得 Session 資料
    if (sessionmodel == null || sessionmodel.Result == null)
    {
        return false;  // 無法取得 Session 資料，可能是 Token 過期或無效
    }

    // 將 Session 資料回傳給呼叫端
    sessiondata = sessionmodel.Result;

    // 檢查 Session 中是否包含有效的公司統一編號
    // ComId 不為空表示使用者已完成登入流程
    return !string.IsNullOrEmpty(sessiondata.ComId);
}

// 檢查功能權限的方法
// 根據使用者的角色和功能代碼判斷是否有執行權限
public bool CheckFuncAuth(string funcCode, MitfSessionDataModel? sessiondata)
{
    // 檢查 Session 資料是否有效
    if (sessiondata == null)
    {
        return false;
    }

    // 這裡可以實作複雜的權限邏輯，例如：
    // 1. 檢查使用者角色是否有權限執行此功能
    // 2. 檢查功能是否在使用者的權限清單中
    // 3. 檢查是否有特殊的業務規則限制

    // 簡化版本：所有已登入的使用者都有基本功能權限
    // 實際專案中會根據角色權限表進行更細緻的檢查
    return true;
}
```

**程式碼說明：**

1. **分層驗證**：先檢查登入狀態，再檢查功能權限，確保安全性的完整性
2. **Token 驗證**：透過 JWT Token 從 Redis 快取中取得使用者 Session，避免每次都查詢資料庫
3. **Session 管理**：使用 Redis 儲存 Session 資料，支援分散式部署和快速存取
4. **參考參數**：使用 `ref` 參數回傳 Session 資料，避免重複查詢
5. **錯誤代碼**：使用統一的錯誤代碼系統，便於前端處理不同的錯誤情況
6. **權限擴展**：權限檢查方法可以根據業務需求擴展更複雜的權限邏輯

## 3. 服務層業務邏輯實作

### 3.1 服務介面定義

**檔案位置：** `MITAP2024/MITAP2024.Server/MITF/MIT01/Service/MIT0101Service.cs`

```csharp
public interface IMIT0101Service
{
    /// <summary>
    /// 查詢申請案件
    /// </summary>
    Task<ActionResult<PagedQueryResult>> Query(MIT0101QueryModel model, MitfSessionDataModel? sessiondata);

    /// <summary>
    /// 新增或更新申請案件
    /// </summary>
    Task<ActionResult<PagedQueryResult>> UpdateForm(MIT0101Model model, MitfSessionDataModel? sessiondata);

    /// <summary>
    /// 送出申請案件
    /// </summary>
    Task<ActionResult<PagedQueryResult>> SendForm(MIT0102QueryModel model, MitfSessionDataModel? sessiondata);

    /// <summary>
    /// 產生申請書
    /// </summary>
    Task<ActionResult<PagedQueryResult>> GenFormReport(BaseUpdateModel model, MitfSessionDataModel? sessiondata);
}
```

### 3.2 核心業務邏輯實作

```csharp
public class MIT0101Service : MitfBaseService, IMIT0101Service
{
    private readonly MainDbContext _context;
    private ILog logger;

    public MIT0101Service(MainDbContext context)
    {
        _context = context;
        logger = LogManager.GetLogger(AppSettingReader.GetLoggerName());
    }

    /// <summary>
    /// 送出申請案件
    /// </summary>
    public async Task<ActionResult<PagedQueryResult>> SendForm(MIT0102QueryModel model, MitfSessionDataModel? sessiondata)
    {
        return await Task.Run(() =>
        {
            PagedQueryResult result = new PagedQueryResult()
            {
                jwtkey = model.jwtkey,
                IsSuccess = false
            };

            try
            {
                // 1. 資料驗證
                var applyform = _context.ApplyForm.Find(Guid.Parse(model.guid));
                if (applyform == null)
                {
                    result.message = "案件不存在";
                    return result;
                }

                // 2. 檢查案件狀態
                if (applyform.FormProcess != "D")
                {
                    result.message = "案件狀態不正確，無法送出";
                    return result;
                }

                // 3. 業務邏輯處理
                var applyformext = _context.ApplyFormExt.Find(applyform.Guid);
                var productindustry = _context.ProductIndustry.Find(applyformext.ProductIndustryTypeGuId);
                var industry = _context.IndustryDetail.Find(productindustry.IndustryGuId);

                // 4. 更新案件狀態
                applyform.FormProcess = "T";
                applyform.ModifyDate = DateTime.Now;
                applyform.ModifyUser = sessiondata?.ManName ?? "系統";

                // 5. 產生申請編號
                string formId = GenerateFormId(industry, applyform);
                applyform.FormId = formId;

                // 6. 儲存變更
                _context.ApplyForm.Update(applyform);
                _context.ApplyFormExt.Update(applyformext);
                _context.SaveChanges();

                // 7. 更新流程記錄
                FormUtils.UpdateFormFlowLog(_context, applyform, productindustry);

                // 8. 產生申請書
                ApplyFormPaperUtil.GenApplyFormForA001A005(_context, applyform.Guid, ref result);

                // 9. 發送通知郵件
                SendNotificationEmail(applyform, industry, sessiondata);

                result.Data = formId;
                result.IsSuccess = true;
            }
            catch (Exception e)
            {
                result.message = TextUtils.GenErrmsgWithNum(logger, "申請案件送審失敗", e);
                result.IsSuccess = false;
            }

            return result;
        });
    }

    /// <summary>
    /// 資料驗證
    /// </summary>
    private bool CheckFormModelDataHasError(MIT0101Model model, ref PagedQueryResult result, bool iscreate = false)
    {
        bool hasError = false;

        if (model.industry == null)
        {
            result.message = TextUtils.AppendMessageWithComma("主分類不可空白", result.message);
            hasError = true;
        }

        if (model.productIndustry == null)
        {
            result.message = TextUtils.AppendMessageWithComma("次分類不可空白", result.message);
            hasError = true;
        }

        if (model.form == null)
        {
            result.message = TextUtils.AppendMessageWithComma("案件資料不可為空", result.message);
            hasError = true;
        }

        return hasError;
    }
}
```

## 4. 資料存取層實作

### 4.1 Entity Framework 資料模型

**檔案位置：** `MITAP2024/MITAP2024.Server/Models/Mit/ApplyForm.cs`

```csharp
/// <summary>
/// 申請案件主檔
/// </summary>
[Table("ApplyForm")]
public partial class ApplyForm
{
    /// <summary>
    /// 主鍵
    /// </summary>
    [Key]
    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
    public required Guid Guid { get; set; }

    /// <summary>
    /// 申請案號
    /// </summary>
    [Required, StringLength(40)]
    public required string FormId { get; set; }

    /// <summary>
    /// 申請作業代碼
    /// </summary>
    [Required, StringLength(8)]
    public required string FormType { get; set; }

    /// <summary>
    /// 申請公司統一編號
    /// </summary>
    [Required, StringLength(100)]
    public required string ComId { get; set; }

    /// <summary>
    /// 案件處理狀態
    /// </summary>
    [StringLength(2)]
    public string? FormProcess { get; set; }

    /// <summary>
    /// 憑證類型
    /// </summary>
    public int? Certtype { get; set; }

    /// <summary>
    /// 憑證資料
    /// </summary>
    [StringLength(-1)]
    public string? Certdata { get; set; }

    // ... 其他欄位
}
```

### 4.2 資料庫上下文設定

**檔案位置：** `MITAP2024/MITAP2024.Server/Models/MainDbContext.cs`

```csharp
public partial class MainDbContext : DbContext
{
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(AppSettingReader.GetMitDbConnStr());
    }

    // MIT 相關資料表
    public DbSet<ApplyForm> ApplyForm { get; set; }
    public DbSet<ApplyFormExt> ApplyFormExt { get; set; }
    public DbSet<ComMain> ComMain { get; set; }
    public DbSet<ComMan> ComMan { get; set; }
    public DbSet<ProductData> ProductData { get; set; }
    public DbSet<IndustryDetail> IndustryDetail { get; set; }
    public DbSet<ProductIndustry> ProductIndustry { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // 設定唯一索引
        modelBuilder.Entity<ApplyForm>().HasIndex(p => new { p.FormSysId }).IsUnique();

        // 設定關聯性
        modelBuilder.Entity<ApplyFormExt>()
            .HasOne<ApplyForm>()
            .WithOne()
            .HasForeignKey<ApplyFormExt>(e => e.Guid);
    }
}
```

## 5. Session 管理與快取機制

### 5.1 Session 管理

**檔案位置：** `MITAP2024/MITAP2024.Server/Utils/Session/SessionManager.cs`

```csharp
public class SessionManager
{
    /// <summary>
    /// 產生 Session Key
    /// </summary>
    public async static Task<string> GenSessionKey()
    {
        return await Task.Run(() =>
        {
            string jwtkey = "mit" + TextUtils.GuidToString(Guid.NewGuid());
            return jwtkey;
        });
    }

    /// <summary>
    /// 設定前台 Session 資料
    /// </summary>
    public async static Task<bool> SetMitfSessionData(string jwtkey, MitfSessionDataModel sessionData)
    {
        IDatabase? sessionDb = GetSessionDB();
        if (sessionDb == null)
        {
            throw new Exception(ConstMsg.ERR_CODE_90001);
        }

        string sessionDataJson = JsonSerializer.Serialize(sessionData);
        TimeSpan expiry = TimeSpan.FromMinutes(AppSettingReader.GetRedisExpire());

        return await sessionDb.StringSetAsync($"mitf:{jwtkey}", sessionDataJson, expiry);
    }

    /// <summary>
    /// 取得前台 Session 資料
    /// </summary>
    public static Task<MitfSessionDataModel?> GetMitfSessionData(string jwtkey)
    {
        return Task.Run(() =>
        {
            IDatabase? sessionDb = GetSessionDB();
            if (sessionDb == null)
            {
                return null;
            }

            var sessionDataJson = sessionDb.StringGet($"mitf:{jwtkey}");
            if (!sessionDataJson.HasValue)
            {
                return null;
            }

            return JsonSerializer.Deserialize<MitfSessionDataModel>(sessionDataJson);
        });
    }

    private static IDatabase? GetSessionDB()
    {
        try
        {
            var redis = ConnectionMultiplexer.Connect(AppSettingReader.GetRedisAddress());
            return redis.GetDatabase();
        }
        catch
        {
            return null;
        }
    }
}
```

### 5.2 前端 Session API

**檔案位置：** `MITAP2024/mitap2024.client/src/composables/SessionApi.ts`

```typescript
export interface SessionData {
  token: string;
  bSessionData: MainSessionData | null;
  fSessionData: MitfSessionData | null;
  departments: Department[] | null;
  sysapps: SysApp[] | null;
  roles: Role[] | null;
}

export interface MitfSessionData {
  manName: string;
  manMail: string;
  needResetPw: string;
  comId: string;
  comName: string;
  isAgent: boolean;
}

export default function SessionApi() {
  const key_jwt = "mit";

  const getSessionData = () => {
    let sdata: SessionData = initSessionData();
    const sdatastr = sessionStorage.getItem(key_jwt);
    if (sdatastr != null && !TextUtilApi().isNullOrEmpty(sdatastr)) {
      sdata = JSON.parse(sdatastr);
    }
    return sdata;
  };

  const setToken = (value: string) => {
    let sdata = getSessionData();
    sdata.token = value;
    setSessionData(sdata);
  };

  const getToken = (): string => {
    let sdata = getSessionData();
    return sdata.token;
  };

  const mitf_setSdata = (value: MitfSessionData) => {
    let sdata = getSessionData();
    sdata.fSessionData = value;
    setSessionData(sdata);
  };

  const mitf_isLogin = (): boolean => {
    let sdata = getSessionData();
    return (
      sdata.fSessionData != null &&
      !TextUtilApi().isNullOrEmpty(sdata.fSessionData.comId)
    );
  };

  return {
    setToken,
    getToken,
    mitf_setSdata,
    mitf_isLogin
    // ... 其他方法
  };
}
```

## 6. 錯誤處理與日誌記錄

### 6.1 統一錯誤處理

```csharp
// TextUtils.cs 中的錯誤處理工具
public static string GenErrmsgWithNum(ILog logger, string message, Exception e)
{
    string errorNum = DateTime.Now.ToString("yyyyMMddHHmmss");
    string fullMessage = $"[{errorNum}] {message}: {e.Message}";

    logger.Error(fullMessage, e);

    return $"{message} (錯誤編號: {errorNum})";
}

public static string AppendMessageWithComma(string newMessage, string existingMessage)
{
    if (string.IsNullOrEmpty(existingMessage))
    {
        return newMessage;
    }
    return $"{existingMessage}, {newMessage}";
}
```

### 6.2 前端錯誤處理

```typescript
// CommonUtilApi.ts 中的錯誤處理
const mitf_DealFetchFailMsg = (json: any): boolean => {
  if (typeof json === "undefined" || json === null) {
    alert("系統錯誤，請聯絡管理員");
    return false;
  }

  if (json.isSuccess === false) {
    if (json.message === ConstMsg().ERR_NOTLOGIN) {
      alert("登入逾時，請重新登入");
      SessionApi().removeSessionData();
      router.push("/mitf/login");
      return false;
    } else {
      alert(json.message || "操作失敗");
      return false;
    }
  }

  return true;
};
```

## 7. 完整資料流程圖

```
前端操作流程：
1. 使用者填寫申請表單
2. 點擊「送出申請」按鈕
3. 前端驗證必填欄位
4. 呼叫 API：POST /api/mitf/mit01/MIT0101/DoSendForm

後端處理流程：
5. 控制器接收請求
6. 驗證 JWT Token 與權限
7. 呼叫服務層處理業務邏輯
8. 資料驗證與狀態檢查
9. 更新資料庫記錄
10. 產生申請書 PDF
11. 發送通知郵件
12. 回傳處理結果

前端後續處理：
13. 接收 API 回應
14. 顯示成功訊息
15. 跳轉至案件列表頁面
```

## 8. 開發與維護指南

### 8.1 新增類似功能的步驟

1. **建立資料模型**：在 `Models` 目錄下建立對應的 Entity 類別
2. **建立 ViewModel**：在對應的 `ViewModel` 目錄下建立資料傳輸物件
3. **建立服務介面與實作**：在 `Service` 目錄下建立業務邏輯
4. **建立控制器**：在 `Controller` 目錄下建立 API 端點
5. **建立前端組件**：在對應的 Vue 目錄下建立使用者介面
6. **設定路由**：在 `routers.ts` 中新增路由設定
7. **註冊服務**：在 `Program.cs` 中註冊 DI 服務

### 8.2 測試建議

1. **單元測試**：針對服務層的業務邏輯撰寫單元測試
2. **整合測試**：測試 API 端點的完整流程
3. **前端測試**：使用 Vue Test Utils 測試組件行為
4. **端對端測試**：使用 Playwright 或 Cypress 測試完整使用者流程

### 8.3 效能優化建議

1. **資料庫查詢優化**：使用適當的索引與查詢策略
2. **快取策略**：善用 Redis 快取常用資料
3. **分頁處理**：大量資料使用分頁載入
4. **非同步處理**：耗時操作使用背景工作處理

這個範例展示了完整的全端開發流程，從前端使用者介面到後端資料處理，涵蓋了身份驗證、資料驗證、業務邏輯處理、錯誤處理等各個面向，為團隊提供了完整的開發參考範本。

```

```
