# 電子病歷申請系統 (EECOnline) - 全端功能詳細範例：數據統計分析報表

## 功能概述

本文以「電子病歷申請案件統計分析功能」為例，詳細說明從前端數據查詢到後端統計計算的完整全端開發流程。此功能涵蓋了複雜條件查詢、數據聚合統計、圖表視覺化、Excel 匯出等數據分析機制，與第三個文件的文檔型報表形成對比。

## 系統架構層次

```
前端 ASP.NET MVC 應用
    ↓ HTTP 請求（統計查詢）
後端 ASP.NET MVC Controller
    ↓ 業務邏輯處理
Action 層 (Business Logic Layer)
    ↓ 統計查詢工具
數據統計分析工具 (StatisticsUtil)
    ↓ SQL 聚合查詢
SQL Server 資料庫 (GROUP BY, COUNT, SUM)
    ↓ 數據處理
統計結果計算與格式化
    ↓ 前端展示
圖表視覺化 + Excel 匯出
```

## 1. 前端統計查詢實作

### 1.1 統計查詢條件設定

**檔案位置：** `ES/Areas/BACKMIN/Controllers/ReportController.cs`

```csharp
/// <summary>
/// 申請統計報表控制器
/// 這個控制器負責處理各種統計報表的查詢和展示
/// </summary>
public class ReportController : BaseController
{
    /// <summary>
    /// 申請統計查詢頁面（GET）
    /// 第一步：顯示統計查詢的初始頁面
    /// </summary>
    [HttpGet]
    public ActionResult CaseSum()
    {
        // 建立查詢條件模型
        CaseSumModel model = new CaseSumModel();

        // 預設查詢當天資料
        // 這樣使用者開啟頁面時就能看到今天的統計資料
        model.Sdate = DateTime.Now.ToString("yyyy/MM/dd");
        model.Fdate = DateTime.Now.ToString("yyyy/MM/dd");

        // 初始化時不執行前端函數
        ViewBag.CallFunc = "";

        // 記錄訪問記錄
        // 用於追蹤哪些使用者使用了統計功能
        this.SetVisitRecord("Report", "CaseSum", "申辦統計");

        return View(model);
    }

    /// <summary>
    /// 申請統計查詢（POST）
    /// 第二步：使用者提交查詢條件後執行統計
    /// </summary>
    [HttpPost]
    public ActionResult CaseSum(CaseSumModel model)
    {
        // 執行前端分頁函數
        // 當查詢完成後，自動執行前端的分頁初始化
        ViewBag.CallFunc = "classpage();";

        return View(model);
    }

    /// <summary>
    /// 申請統計報表 AJAX 查詢
    /// 第三步：透過 AJAX 非同步取得統計資料
    /// 這個方法會被前端 JavaScript 呼叫，回傳部分視圖
    /// </summary>
    public ActionResult CaseSumReport(string Sdate, string Fdate)
    {
        // 建立查詢條件模型
        CaseSumModel model = new CaseSumModel();
        model.Fdate = Fdate;
        model.Sdate = Sdate;

        // 呼叫 Action 層執行統計查詢
        ReportAction action = new ReportAction();
        ViewBag.List = action.GetCaseSumReport(model);

        // 回傳部分視圖（Partial View）
        // 只更新頁面中的統計結果區域，不重新載入整個頁面
        return View(model);
    }
}
```

**程式碼說明：**

1. **GET 方法**：初始化頁面，設定預設查詢條件為當天日期
2. **POST 方法**：接收使用者提交的查詢條件，執行統計查詢
3. **AJAX 方法**：提供非同步查詢功能，提升使用者體驗
4. **訪問記錄**：記錄使用者的操作行為，用於系統使用分析
5. **ViewBag 傳遞**：使用 ViewBag 在控制器和視圖之間傳遞資料

### 1.2 統計查詢視圖介面

**檔案位置：** `ES/Areas/BACKMIN/Views/Report/CaseSum.cshtml`

```html
@model ES.Areas.BACKMIN.Models.CaseSumModel

<div class="container-fluid">
  <div class="card">
    <div class="card-header">
      <h4>申請案件統計分析</h4>
    </div>

    <!-- 統計查詢條件區域 -->
    <div class="card-body">
      @using (Html.BeginForm("CaseSum", "Report", FormMethod.Post, new { @class
      = "form-horizontal" })) {
      <div class="row">
        <div class="col-md-4">
          <div class="form-group">
            <label>統計開始日期</label>
            @Html.TextBoxFor(m => m.Sdate, new { @class = "form-control
            datepicker", @placeholder = "請選擇開始日期" })
          </div>
        </div>
        <div class="col-md-4">
          <div class="form-group">
            <label>統計結束日期</label>
            @Html.TextBoxFor(m => m.Fdate, new { @class = "form-control
            datepicker", @placeholder = "請選擇結束日期" })
          </div>
        </div>
        <div class="col-md-4">
          <div class="form-group">
            <label>&nbsp;</label>
            <button type="submit" class="btn btn-primary btn-block">
              <i class="fa fa-search"></i> 執行統計分析
            </button>
          </div>
        </div>
      </div>
      }
    </div>

    <!-- 統計結果顯示區域 -->
    <div class="card-body" id="statisticsResult">
      @if (ViewBag.List != null) {
      <div class="table-responsive">
        <table class="table table-striped table-bordered">
          <thead class="thead-dark">
            <tr>
              <th>單位名稱</th>
              <th>服務項目</th>
              <th>申請案件數</th>
              <th>操作</th>
            </tr>
          </thead>
          <tbody>
            @foreach (var item in ViewBag.List) {
            <tr>
              <td>@item.UNIT_NAME</td>
              <td>@item.SRV_NAME</td>
              <td class="text-right">@item.APP_COUNT</td>
              <td>
                <button
                  class="btn btn-sm btn-info"
                  onclick="showDetail('@item.SRV_ID')">
                  <i class="fa fa-eye"></i> 查看明細
                </button>
              </td>
            </tr>
            }
          </tbody>
        </table>
      </div>

      <!-- 匯出功能按鈕 -->
      <div class="text-right mt-3">
        <button class="btn btn-success" onclick="exportToExcel()">
          <i class="fa fa-file-excel"></i> 匯出 Excel
        </button>
      </div>
      }
    </div>
  </div>
</div>

<script>
  // 初始化日期選擇器
  $(document).ready(function() {
      $('.datepicker').datepicker({
          format: 'yyyy/mm/dd',
          autoclose: true,
          todayHighlight: true
      });

      // 執行控制器傳遞的前端函數
      @Html.Raw(ViewBag.CallFunc)
  });

  // 查看明細功能
  function showDetail(srvId) {
      // 實作查看明細的邏輯
      window.location.href = '@Url.Action("CaseDetail", "Report")?srvId=' + srvId;
  }

  // Excel 匯出功能
  function exportToExcel() {
      // 實作 Excel 匯出的邏輯
      window.location.href = '@Url.Action("ExportCaseSum", "Report")?Sdate=' + $('#Sdate').val() + '&Fdate=' + $('#Fdate').val();
  }
</script>
```

**程式碼說明：**

1. **表單設計**：使用 Bootstrap 卡片和表單組件建立清晰的查詢介面
2. **日期選擇器**：整合 jQuery UI Datepicker 提供友善的日期選擇功能
3. **響應式表格**：使用 Bootstrap 的 table-responsive 確保在不同裝置上都能正常顯示
4. **互動功能**：提供查看明細和匯出 Excel 的按鈕
5. **動態執行**：透過 ViewBag.CallFunc 動態執行前端函數

### 涉及的主要技術

| 技術       | 用途       | 說明                       |
| ---------- | ---------- | -------------------------- |
| SQL Server | 資料庫     | 儲存申請、登入、繳費等資料 |
| ADO.NET    | 資料存取   | 直接 SQL 查詢              |
| Hangfire   | 背景排程   | 定期執行統計任務           |
| NPOI       | Excel 匯出 | 產生 Excel 報表            |
| Chart.js   | 圖表呈現   | 前端圖表視覺化             |

### 涉及的資料表

| 資料表             | 說明         |
| ------------------ | ------------ |
| TblEEC_Apply       | 申請主檔     |
| TblEEC_ApplyDetail | 申請明細檔   |
| TblEEC_Hospital    | 醫院資料檔   |
| TblEEC_User        | 使用者資料檔 |
| TblLOGINLOG        | 登入記錄檔   |

## 2. 後端統計分析 Action 層實作

### 2.1 統計查詢業務邏輯

**檔案位置：** `ES/Areas/BACKMIN/Action/ReportAction.cs`

```csharp
/// <summary>
/// 統計分析的核心業務邏輯類別
/// 執行複雜的 SQL 聚合查詢，計算各種統計指標
/// </summary>
public class ReportAction
{
    /// <summary>
    /// 取得申請統計資料
    /// 執行基本的統計查詢，計算各服務項目的申請案件數
    /// </summary>
    /// <param name="model">查詢條件模型</param>
    /// <returns>統計結果清單</returns>
    public List<CaseSumResultModel> GetCaseSumReport(CaseSumModel model)
    {
        // 第一步：預設值處理
        // 確保日期參數不為空，避免 SQL 查詢錯誤
        if (String.IsNullOrEmpty(model.Sdate))
            model.Sdate = DateTime.Now.ToString("yyyy/MM/dd");
        if (String.IsNullOrEmpty(model.Fdate))
            model.Fdate = Convert.ToDateTime(model.Sdate).ToString("yyyy/MM/dd");

        // 初始化結果清單
        List<CaseSumResultModel> li = new List<CaseSumResultModel>();

        // 第二步：建立資料庫連線
        using (SqlConnection conn = DataUtils.GetConnection())
        {
            conn.Open();

            // 第三步：開啟交易
            // 雖然這是查詢操作，但使用交易可以確保資料一致性
            using (SqlTransaction st = conn.BeginTransaction())
            {
                using (SqlCommand dbc = conn.CreateCommand())
                {
                    dbc.Transaction = st;

                    // 第四步：建立統計 SQL 查詢
                    // 使用 LEFT JOIN 確保即使沒有申請案件，服務項目也會顯示（數量為 0）
                    dbc.CommandText = @"
                        SELECT
                            S.SRV_ID,                    -- 服務代碼
                            S.NAME AS SRV_NAME,          -- 服務名稱
                            S.UNIT_CD,                   -- 單位代碼
                            U.NAME AS UNIT_NAME,         -- 單位名稱
                            COUNT(A.APP_ID) AS APP_COUNT -- 申請案件數（使用 COUNT 聚合函數）
                        FROM SERVICE S
                            LEFT JOIN APPLY A ON S.SRV_ID = A.SRV_ID
                                AND A.APPLY_DATE >= @Sdate      -- 申請日期大於等於開始日期
                                AND A.APPLY_DATE < @Fdate       -- 申請日期小於結束日期（不包含結束日）
                                AND A.DEL_MK = 'N'              -- 只統計未刪除的申請案件
                            LEFT JOIN UNIT U ON S.UNIT_CD = U.UNIT_CD
                        WHERE S.DEL_MK = 'N'                    -- 只統計未刪除的服務項目
                        GROUP BY S.SRV_ID, S.NAME, S.UNIT_CD, U.NAME  -- 依服務和單位分組
                        ORDER BY S.UNIT_CD, S.SRV_ID";          -- 依單位和服務代碼排序

                    // 第五步：設定查詢參數
                    // 使用參數化查詢防止 SQL Injection 攻擊
                    DataUtils.AddParameters(dbc, "Sdate", model.Sdate);
                    // 結束日期加一天，確保包含當天的所有資料
                    DataUtils.AddParameters(dbc, "Fdate", Convert.ToDateTime(model.Fdate).AddDays(1));

                    // 第六步：執行查詢並讀取結果
                    using (SqlDataReader sda = dbc.ExecuteReader())
                    {
                        while (sda.Read())
                        {
                            // 建立統計結果物件
                            CaseSumResultModel item = new CaseSumResultModel();
                            item.SRV_ID = DataUtils.GetDBString(sda, "SRV_ID");
                            item.SRV_NAME = DataUtils.GetDBString(sda, "SRV_NAME");
                            item.UNIT_CD = DataUtils.GetDBString(sda, "UNIT_CD");
                            item.UNIT_NAME = DataUtils.GetDBString(sda, "UNIT_NAME");
                            item.APP_COUNT = DataUtils.GetDBInt(sda, "APP_COUNT");
                            li.Add(item);
                        }
                        sda.Close();
                    }
                }
            }

            conn.Close();
            conn.Dispose();
        }

        return li;
    }
}
```

**程式碼說明：**

1. **LEFT JOIN 策略**：使用 LEFT JOIN 確保即使沒有申請案件，服務項目也會顯示（數量為 0）
2. **日期範圍處理**：使用 `>=` 和 `<` 確保日期範圍正確（包含起始日，不包含結束日的下一天）
3. **GROUP BY 聚合**：依服務代碼、服務名稱、單位代碼、單位名稱分組
4. **COUNT 函數**：計算每個服務的申請案件數
5. **參數化查詢**：使用參數化查詢防止 SQL Injection 攻擊
6. **資源管理**：使用 using 語句確保資料庫連線和資源正確釋放

### 2.2 登入統計分析實作

```csharp
/// <summary>
/// 取得登入統計資料
/// 統計各種登入方式的使用次數
/// </summary>
/// <param name="model">查詢條件模型</param>
/// <returns>統計結果字典</returns>
public Dictionary<string, int> GetLoginReport(StatisticsLoginModel model)
{
    // 使用 Dictionary 儲存各登入方式的統計結果
    Dictionary<string, int> map = new Dictionary<string, int>();

    try
    {
        using (SqlConnection conn = DataUtils.GetConnection())
        {
            conn.Open();
            using (SqlCommand dbc = conn.CreateCommand())
            {
                // 統計 SQL 查詢
                // 使用 SUM 函數統計各登入方式的總次數
                dbc.CommandText = @"
                    SELECT
                        SUM(member) AS member,      -- 會員登入總次數
                        SUM(moica) AS moica,        -- 自然人憑證登入總次數
                        SUM(moeaca) AS moeaca,      -- 行動自然人憑證登入總次數
                        SUM(hca0) AS hca0,          -- 健保卡（讀卡機）登入總次數
                        SUM(hca1) AS hca1,          -- 健保卡（行動）登入總次數
                        SUM(NEWEID) AS NEWEID       -- 數位身分證登入總次數
                    FROM LOGIN_STATISTICS
                    WHERE LOGIN_DATE >= @Sdate
                      AND LOGIN_DATE <= @Fdate";

                dbc.Parameters.Clear();
                DataUtils.AddParameters(dbc, "Sdate", model.Sdate);
                DataUtils.AddParameters(dbc, "Fdate", Convert.ToDateTime(model.Fdate).AddDays(1));

                using (SqlDataReader sda = dbc.ExecuteReader())
                {
                    if (sda.Read())
                    {
                        // 將各登入方式的統計結果加入字典
                        map.Add("member", DataUtils.GetDBInt(sda, 0));
                        map.Add("moica", DataUtils.GetDBInt(sda, 1));
                        map.Add("moeaca", DataUtils.GetDBInt(sda, 2));
                        map.Add("hca0", DataUtils.GetDBInt(sda, 3));
                        map.Add("hca1", DataUtils.GetDBInt(sda, 4));
                        map.Add("NEWEID", DataUtils.GetDBInt(sda, 5));
                    }
                    sda.Close();
                }
            }
            conn.Close();
            conn.Dispose();
        }
    }
    catch (Exception ex)
    {
        LOG.Error("GetLoginReport() Error: " + ex.Message);
    }

    return map;
}
```

**程式碼說明：**

1. **SUM 聚合函數**：使用 SUM 函數統計各登入方式的總次數
2. **多欄位統計**：一次查詢取得所有登入方式的統計，提升效能
3. **Dictionary 回傳**：使用字典結構方便前端取值和顯示
4. **NULL 處理**：SUM 函數自動處理 NULL 值（回傳 0）
5. **錯誤處理**：使用 try-catch 捕捉異常，記錄錯誤日誌

## 3. Hangfire 背景排程系統

### 3.1 HangfireBootstrapper 啟動器

**檔案位置：** `HangfireBootstrapper.cs`

```csharp
using System;
using System.Web.Hosting;
using Hangfire;
using Hangfire.SqlServer;

namespace EECOnline
{
    /// <summary>
    /// Hangfire 背景任務啟動器
    /// 實作 IRegisteredObject 介面，確保應用程式關閉時正確停止背景任務
    /// </summary>
    public class HangfireBootstrapper : IRegisteredObject
    {
        // 單例模式
        public static readonly HangfireBootstrapper Instance = new HangfireBootstrapper();

        private readonly object _lockObject = new object();
        private bool _started;
        private BackgroundJobServer _backgroundJobServer;

        private HangfireBootstrapper()
        {
        }

        /// <summary>
        /// 啟動 Hangfire 背景任務伺服器
        /// </summary>
        public void Start()
        {
            lock (_lockObject)
            {
                // 防止重複啟動
                if (_started) return;
                _started = true;

                // 註冊到 HostingEnvironment，確保應用程式關閉時會呼叫 Stop()
                HostingEnvironment.RegisterObject(this);

                // 設定使用 SQL Server 儲存 Hangfire 資料
                // connectionEUSERVICE 是 Web.config 中的連線字串名稱
                GlobalConfiguration.Configuration.UseSqlServerStorage("connectionEUSERVICE");

                // 建立背景任務伺服器
                _backgroundJobServer = new BackgroundJobServer();
            }
        }

        /// <summary>
        /// 停止 Hangfire 背景任務伺服器
        /// </summary>
        public void Stop()
        {
            lock (_lockObject)
            {
                if (_backgroundJobServer != null)
                {
                    _backgroundJobServer.Dispose();
                }

                HostingEnvironment.UnregisterObject(this);
            }
        }

        /// <summary>
        /// IRegisteredObject 介面實作
        /// </summary>
        void IRegisteredObject.Stop(bool immediate)
        {
            Stop();
        }
    }
}
```

**程式碼說明：**

1. **單例模式**：使用 `Instance` 靜態屬性確保只有一個實例
2. **執行緒安全**：使用 `lock` 確保多執行緒環境下的安全性
3. **IRegisteredObject**：實作此介面確保應用程式關閉時正確停止背景任務
4. **SQL Server 儲存**：使用 SQL Server 儲存 Hangfire 的任務資料（比記憶體儲存更可靠）

### 2.2 Global.asax.cs 啟動 Hangfire

**檔案位置：** `Global.asax.cs`

```csharp
protected void Application_Start()
{
    AreaRegistration.RegisterAllAreas();
    FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
    RouteConfig.RegisterRoutes(RouteTable.Routes);
    BundleConfig.RegisterBundles(BundleTable.Bundles);

    // 啟動 Hangfire 背景任務
    HangfireBootstrapper.Instance.Start();
}
```

**程式碼說明：**

1. **應用程式啟動時執行**：在 `Application_Start()` 中啟動 Hangfire
2. **自動啟動**：應用程式啟動後，Hangfire 會自動開始處理背景任務

### 2.3 Hangfire Dashboard 設定

**檔案位置：** `Startup.cs`（109_e-service 專案）

```csharp
using Owin;
using Hangfire;
using Hangfire.Dashboard;

namespace ES
{
    public class Startup
    {
        public void Configuration(IAppBuilder app)
        {
            // 使用記憶體儲存（開發環境）
            // 生產環境建議使用 SQL Server 儲存
            GlobalConfiguration.Configuration.UseMemoryStorage();

            // 設定背景任務伺服器選項
            var options = new BackgroundJobServerOptions
            {
                ServerCheckInterval = TimeSpan.FromMinutes(20),  // 伺服器檢查間隔
                HeartbeatInterval = TimeSpan.FromMinutes(20),    // 心跳間隔
                CancellationCheckInterval = TimeSpan.FromMinutes(20),  // 取消檢查間隔
            };

            // 啟動 Hangfire 伺服器
            app.UseHangfireServer(options);

            // 啟動 Hangfire Dashboard（監控介面）
            // 路徑：/EserviceHangFire
            app.UseHangfireDashboard("/EserviceHangFire",
                new DashboardOptions
                {
                    // 設定授權過濾器（只有授權使用者可存取）
                    Authorization = new[] { new DashboardAccessAuthFilter() },
                });
        }
    }
}
```

**程式碼說明：**

1. **記憶體儲存**：開發環境使用 `UseMemoryStorage()`，重啟後任務資料會遺失
2. **SQL Server 儲存**：生產環境建議使用 `UseSqlServerStorage()`，資料持久化
3. **Dashboard 路徑**：`/EserviceHangFire` 可存取監控介面
4. **授權過濾器**：使用自訂的 `DashboardAccessAuthFilter` 控制存取權限

### 2.4 Dashboard 授權過濾器

```csharp
using Hangfire.Dashboard;

namespace ES
{
    /// <summary>
    /// Hangfire Dashboard 授權過濾器
    /// 控制誰可以存取 Hangfire 監控介面
    /// </summary>
    public class DashboardAccessAuthFilter : IDashboardAuthorizationFilter
    {
        public bool Authorize(DashboardContext context)
        {
            // 取得目前登入的使用者
            var httpContext = System.Web.HttpContext.Current;

            // 檢查是否已登入
            if (httpContext == null || httpContext.User == null || !httpContext.User.Identity.IsAuthenticated)
            {
                return false;
            }

            // 檢查是否為管理員角色
            if (httpContext.User.IsInRole("Admin"))
            {
                return true;
            }

            return false;
        }
    }
}
```

**程式碼說明：**

1. **IDashboardAuthorizationFilter**：實作此介面自訂授權邏輯
2. **登入檢查**：檢查使用者是否已登入
3. **角色檢查**：只有 Admin 角色可存取 Dashboard
4. **安全性**：防止未授權使用者存取敏感的任務資訊

## 4. 定期排程任務範例

### 4.1 註冊定期任務

**檔案位置：** `Global.asax.cs` 或 `Startup.cs`

```csharp
using Hangfire;

/// <summary>
/// 註冊定期執行的任務
/// </summary>
private void RegisterRecurringJobs()
{
    // 任務 1：每小時執行一次
    RecurringJob.AddOrUpdate(
        "HourlyTask",                    // 任務 ID（唯一識別）
        () => ExecuteHourlyTask(),       // 要執行的方法
        "0 * * * *",                     // Cron 表達式：每小時的第 0 分鐘
        TimeZoneInfo.Local               // 時區設定
    );

    // 任務 2：每天 21:00 執行
    RecurringJob.AddOrUpdate(
        "DailyTask",
        () => ExecuteDailyTask(),
        "0 21 * * *",                    // Cron 表達式：每天 21:00
        TimeZoneInfo.Local
    );

    // 任務 3：每天 01:00 執行
    RecurringJob.AddOrUpdate(
        "NightlyTask",
        () => ExecuteNightlyTask(),
        "0 1 * * *",                     // Cron 表達式：每天 01:00
        TimeZoneInfo.Local
    );

    // 任務 4：每週一 09:00 執行
    RecurringJob.AddOrUpdate(
        "WeeklyTask",
        () => ExecuteWeeklyTask(),
        "0 9 * * 1",                     // Cron 表達式：每週一 09:00
        TimeZoneInfo.Local
    );
}
```

**Cron 表達式說明：**

```
格式：分 時 日 月 週

範例：
0 * * * *     每小時的第 0 分鐘
0 21 * * *    每天 21:00
0 1 * * *     每天 01:00
0 9 * * 1     每週一 09:00
*/5 * * * *   每 5 分鐘
0 0 1 * *     每月 1 日 00:00
```

### 4.2 立即執行任務

```csharp
// 立即執行一次性任務（背景執行）
BackgroundJob.Enqueue(() => ExecuteTask());

// 延遲執行任務（1 小時後執行）
BackgroundJob.Schedule(() => ExecuteTask(), TimeSpan.FromHours(1));

// 延遲執行任務（指定時間執行）
BackgroundJob.Schedule(() => ExecuteTask(), DateTimeOffset.Now.AddDays(1));
```

### 4.3 任務鏈（依序執行）

```csharp
// 任務 1 執行完後，執行任務 2
var jobId = BackgroundJob.Enqueue(() => ExecuteTask1());
BackgroundJob.ContinueWith(jobId, () => ExecuteTask2());
```

## 5. Excel 匯出功能實作

### 5.1 Excel 匯出控制器

**檔案位置：** `ES/Areas/BACKMIN/Controllers/ReportController.cs`

```csharp
/// <summary>
/// 匯出申請統計報表為 Excel
/// </summary>
public ActionResult ExportCaseSum(string Sdate, string Fdate)
{
    // 第一步：建立查詢條件
    CaseSumModel model = new CaseSumModel();
    model.Sdate = Sdate;
    model.Fdate = Fdate;

    // 第二步：取得統計資料
    ReportAction action = new ReportAction();
    List<CaseSumResultModel> list = action.GetCaseSumReport(model);

    // 第三步：使用 NPOI 建立 Excel 檔案
    var workbook = new XSSFWorkbook(); // 建立 XLSX 格式的工作簿
    var sheet = workbook.CreateSheet("申請統計報表"); // 建立工作表

    // 第四步：建立標題列樣式
    var headerStyle = workbook.CreateCellStyle();
    var headerFont = workbook.CreateFont();
    headerFont.IsBold = true;
    headerFont.FontHeightInPoints = 12;
    headerStyle.SetFont(headerFont);
    headerStyle.FillForegroundColor = IndexedColors.Grey25Percent.Index;
    headerStyle.FillPattern = FillPattern.SolidForeground;

    // 第五步：建立標題列
    var headerRow = sheet.CreateRow(0);
    headerRow.CreateCell(0).SetCellValue("單位名稱");
    headerRow.CreateCell(1).SetCellValue("服務項目");
    headerRow.CreateCell(2).SetCellValue("申請案件數");

    // 套用標題列樣式
    for (int i = 0; i < 3; i++)
    {
        headerRow.GetCell(i).CellStyle = headerStyle;
    }

    // 第六步：填入資料
    int rowIndex = 1;
    foreach (var item in list)
    {
        var dataRow = sheet.CreateRow(rowIndex++);
        dataRow.CreateCell(0).SetCellValue(item.UNIT_NAME);
        dataRow.CreateCell(1).SetCellValue(item.SRV_NAME);
        dataRow.CreateCell(2).SetCellValue(item.APP_COUNT);
    }

    // 第七步：自動調整欄寬
    for (int i = 0; i < 3; i++)
    {
        sheet.AutoSizeColumn(i);
    }

    // 第八步：將 Excel 寫入記憶體串流
    using (var ms = new MemoryStream())
    {
        workbook.Write(ms);

        // 第九步：設定 HTTP 回應標頭
        var fileName = $"申請統計報表_{DateTime.Now:yyyyMMdd}.xlsx";
        Response.ContentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
        Response.AddHeader("Content-Disposition", $"attachment; filename={fileName}");

        // 第十步：回傳檔案
        return File(ms.ToArray(), Response.ContentType, fileName);
    }
}
```

**程式碼說明：**

1. **NPOI 函式庫**：使用 NPOI 產生 Excel 檔案，支援 XLSX 格式
2. **樣式設定**：設定標題列的字體、顏色、背景等樣式
3. **自動調整欄寬**：使用 AutoSizeColumn 自動調整欄寬以適應內容
4. **記憶體串流**：使用 MemoryStream 避免產生暫存檔案
5. **HTTP 標頭設定**：正確設定 Content-Type 和 Content-Disposition 標頭

## 6. 完整資料流程圖

```
數據統計分析完整流程：

前端統計查詢流程：
1. 使用者開啟統計查詢頁面（GET /Report/CaseSum）
2. 頁面顯示預設查詢條件（當天日期）
3. 使用者設定統計查詢條件（開始日期、結束日期）
4. 使用者點擊「執行統計分析」按鈕
5. 提交表單（POST /Report/CaseSum）

後端統計分析流程：
6. 控制器接收統計查詢請求
7. 呼叫 Action 層統計分析方法
8. 建立資料庫連線
9. 執行 SQL 聚合查詢（GROUP BY, COUNT）
10. 讀取查詢結果並建立結果物件清單
11. 關閉資料庫連線
12. 回傳統計分析結果到視圖

前端資料展示流程：
13. 視圖接收統計結果
14. 使用 Bootstrap 表格顯示統計資料
15. 提供查看明細和匯出 Excel 按鈕
16. 使用者可以點擊按鈕執行進一步操作

Excel 匯出流程：
17. 使用者點擊「匯出 Excel」按鈕
18. 前端發送匯出請求（GET /Report/ExportCaseSum）
19. 後端重新執行統計查詢取得資料
20. 使用 NPOI 建立 Excel 工作簿
21. 建立工作表並設定樣式
22. 填入標題列和資料列
23. 自動調整欄寬
24. 將 Excel 寫入記憶體串流
25. 設定 HTTP 回應標頭
26. 回傳 Excel 檔案

檔案下載流程：
27. 瀏覽器接收 Excel 檔案
28. 顯示下載對話框
29. 使用者儲存檔案到本機
30. 完成匯出流程
```

## 7. 數據模型定義

### 7.1 統計查詢條件模型

```csharp
/// <summary>
/// 申請統計查詢條件的資料模型
/// </summary>
public class CaseSumModel
{
    /// <summary>
    /// 統計開始日期
    /// </summary>
    public string Sdate { get; set; }

    /// <summary>
    /// 統計結束日期
    /// </summary>
    public string Fdate { get; set; }
}

/// <summary>
/// 登入統計查詢條件的資料模型
/// </summary>
public class StatisticsLoginModel
{
    /// <summary>
    /// 統計開始日期
    /// </summary>
    public string Sdate { get; set; }

    /// <summary>
    /// 統計結束日期
    /// </summary>
    public string Fdate { get; set; }
}
```

### 7.2 統計結果模型

```csharp
/// <summary>
/// 申請統計結果的資料模型
/// </summary>
public class CaseSumResultModel
{
    /// <summary>
    /// 服務代碼
    /// </summary>
    public string SRV_ID { get; set; }

    /// <summary>
    /// 服務名稱
    /// </summary>
    public string SRV_NAME { get; set; }

    /// <summary>
    /// 單位代碼
    /// </summary>
    public string UNIT_CD { get; set; }

    /// <summary>
    /// 單位名稱
    /// </summary>
    public string UNIT_NAME { get; set; }

    /// <summary>
    /// 申請案件數
    /// </summary>
    public int APP_COUNT { get; set; }
}
```

**程式碼說明：**

1. **分層資料模型**：清楚定義查詢條件和統計結果的資料結構
2. **型別安全**：使用強型別定義，避免資料傳遞錯誤
3. **文件化註解**：詳細的 XML 註解說明每個屬性的用途
4. **簡潔設計**：模型只包含必要的屬性，保持簡潔

## 8. 開發與維護指南

### 8.1 新增統計維度的步驟

當需要新增不同的統計維度時，可以按照以下步驟進行：

1. **建立新的查詢條件模型**

   ```csharp
   public class NewStatisticsModel
   {
       public string Sdate { get; set; }
       public string Fdate { get; set; }
       public string NewCondition { get; set; } // 新增的查詢條件
   }
   ```

2. **建立新的結果模型**

   ```csharp
   public class NewStatisticsResultModel
   {
       public string Category { get; set; }
       public int Count { get; set; }
       // 其他統計欄位
   }
   ```

3. **在 Action 層新增查詢方法**

   ```csharp
   public List<NewStatisticsResultModel> GetNewStatistics(NewStatisticsModel model)
   {
       // 實作統計查詢邏輯
   }
   ```

4. **在控制器新增 Action 方法**
   ```csharp
   public ActionResult NewStatistics(NewStatisticsModel model)
   {
       // 呼叫 Action 層方法並回傳視圖
   }
   ```

### 8.2 效能優化建議

1. **索引優化**

   ```sql
   -- 為統計查詢建立複合索引
   CREATE INDEX IX_APPLY_Statistics
   ON APPLY (APPLY_DATE, DEL_MK, SRV_ID);
   ```

2. **查詢快取**

   - 對於相同條件的統計查詢，可以考慮快取結果
   - 使用 ASP.NET 的 OutputCache 或 MemoryCache

3. **分頁處理**
   - 對於大量統計資料，考慮實作分頁機制
   - 使用 OFFSET-FETCH 或 ROW_NUMBER() 實作分頁

## 9. 總結

本文件詳細說明了 EECOnline 系統的數據統計分析報表功能，包含：

1. **前端查詢介面**：使用 ASP.NET MVC 建立統計查詢頁面
2. **後端統計分析**：使用 SQL 聚合查詢計算統計指標
3. **Hangfire 背景排程**：定期執行統計任務
4. **Excel 匯出功能**：使用 NPOI 產生 Excel 報表
5. **完整資料流程**：從查詢到展示的完整流程
6. **數據模型定義**：清楚的資料結構定義
7. **開發維護指南**：新增功能和效能優化的建議

完整的統計報表實作範例請參考補充文件「04-1*數據統計分析報表補充*統計查詢實作.md」。
