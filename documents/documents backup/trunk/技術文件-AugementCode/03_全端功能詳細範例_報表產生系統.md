# 電子病歷申請系統 (EECOnline) - 全端功能詳細範例：報表產生系統

## 功能概述

本文詳細說明 EECOnline 系統中的報表產生機制，包含 Word 模板套表、PDF 文件產生、HTML 轉 PDF 等功能。系統使用多種文件處理技術，提供完整的報表產製解決方案。

## 報表產生技術架構

```
報表產生流程：

資料查詢
    ↓
資料處理與格式化
    ↓
選擇報表類型
    ├─→ Word 模板套表 (DocX)
    │       ↓
    │   Word 文件產生
    │       ↓
    │   Word 轉 HTML (OpenXmlPowerTools)
    │       ↓
    │   HTML 轉 PDF (Turbo.ReportTK.PDF)
    │       ↓
    │   PDF 加密 (iTextSharp)
    │
    └─→ 直接下載病歷 PDF
            ↓
        PDF 解密 (AES)
            ↓
        回傳檔案
    ↓
檔案儲存/下載
```

### 涉及的主要技術

| 技術                   | 用途              | 套件/函式庫                      |
| ---------------------- | ----------------- | -------------------------------- |
| Xceed.Words.NET        | Word 文件處理     | Xceed.Words.NET (DocX)           |
| OpenXmlPowerTools      | Word 轉 HTML      | OpenXmlPowerTools                |
| Turbo.ReportTK.PDF     | HTML 轉 PDF       | Turbo.ReportTK.PDF.HtmlPDF       |
| iTextSharp             | PDF 加密          | iTextSharp.text.pdf              |
| DocumentFormat.OpenXml | Word 文件處理     | DocumentFormat.OpenXml.Packaging |
| AES 加密               | 病歷檔案加密/解密 | AesCrypto                        |

### 涉及的資料表

| 資料表                          | 說明            |
| ------------------------------- | --------------- |
| TblEEC_Apply                    | 申請主檔        |
| TblEEC_ApplyDetail              | 申請明細檔      |
| TblEEC_ApplyDetailPrice         | 申請明細價格檔  |
| TblEEC_ApplyDetailPrice_ApiData | 病歷 API 資料檔 |
| TblSETUP                        | 系統設定檔      |

## 1. Word 模板套表系統

### 1.1 Word 模板設計

**模板位置：** `App_Data/Temp/電子病歷服務平台繳費明細單_亞東.docx`

#### 1.1.1 模板佔位符設計

```
Word 模板中使用 $ 符號包圍的佔位符：

申請人資訊：
- $APPLYNAME$     申請人姓名
- $BIRYEAR$       出生年（民國年）
- $BIRMONTH$      出生月
- $BIRDAYS$       出生日

繳費資訊：
- $PAYYEAR$       繳費年（民國年）
- $PAYMONTH$      繳費月
- $PAYDAYS$       繳費日
- $PAYMONEY$      繳費金額（千分位格式）

當前日期：
- $CYEAR$         當前年（民國年）
- $CMONTH$        當前月
- $CDAYS$         當前日
```

**模板設計原則：**

1. **佔位符命名**：使用大寫英文，前後加 `$` 符號
2. **日期格式**：統一使用民國年格式
3. **金額格式**：使用千分位分隔符號
4. **版面配置**：使用 Word 表格結構確保對齊

### 1.2 Word 文件處理實作

**檔案位置：** `Controllers/HomeController.cs`

#### 1.2.1 SearchGridDetailPrint01 繳費證明列印（完整程式碼）

```csharp
/// <summary>
/// 列印繳費證明（亞東醫院）
/// 功能：產生繳費證明 PDF 檔案供使用者下載
/// 流程：
/// 1. 檢查申請單號
/// 2. 確認 Word 模板檔案存在
/// 3. 載入申請資料（主檔、明細、價格）
/// 4. 準備套印資料（申請人資訊、繳費資訊、當前日期）
/// 5. 載入 Word 模板並替換佔位符
/// 6. Word 轉 HTML 轉 PDF
/// 7. 加密 PDF（使用者密碼：身分證字號）
/// 8. 記錄 LOG
/// 9. 回傳 PDF 檔案
/// </summary>
/// <param name="model">查詢模型（包含申請單號）</param>
/// <returns>PDF 檔案</returns>
[HttpPost]
public ActionResult SearchGridDetailPrint01(HomeViewModel model)
{
    // 清除模型狀態（避免驗證錯誤）
    ModelState.Clear();

    // 取得 Session
    SessionModel sm = SessionModel.Get();

    #region 1. 檢查申請單號
    if (model.SearchApply.DetailApplyNo.TONotNullString() == "")
    {
        sm.LastErrorMessage = "查無資料！";
        return View("Search", model);
    }
    #endregion

    // 先將列表頁資料記錄起來（使用 ValueInjecter 複製屬性）
    model.SearchApplyDetail = new SearchApplyDetailModel();
    model.SearchApplyDetail.InjectFrom(model.SearchApply);

    #region 2. 確認套印檔案是否存在
    // Word 模板路徑
    var TemplatePath = Server.MapPath("~/App_Data/Temp/電子病歷服務平台繳費明細單_亞東.docx");
    if (!System.IO.File.Exists(TemplatePath))
    {
        sm.LastErrorMessage = "格式檔遺失！";
        return View("Search", model);
    }

    // 暫存資料夾路徑（用於儲存轉換過程中的暫存檔）
    var tmpFolder = Server.MapPath("~/Uploads/WordTemplate/");
    if (!System.IO.File.Exists(tmpFolder))
    {
        System.IO.Directory.CreateDirectory(tmpFolder);
    }
    #endregion

    #region 3. 載入申請資料
    FrontDAO dao = new FrontDAO();

    // 3.1 載入申請明細資料（TblEEC_ApplyDetail）
    var mainData = dao.GetRow(new TblEEC_ApplyDetail()
    {
        apply_no_sub = model.SearchApply.DetailApplyNo
    });

    if (mainData == null)
    {
        sm.LastErrorMessage = "查無資料！";
        return View("Search", model);
    }
    else
    {
        // 複製明細資料到 ViewModel
        model.SearchApplyDetail.InjectFrom(mainData);

        // 3.2 載入申請主檔資料（TblEEC_Apply）
        // 目的：取得申請日期
        var mainDataMst = dao.GetRow(new TblEEC_Apply()
        {
            apply_no = mainData.apply_no
        });
        model.SearchApplyDetail.createdatetime = mainDataMst.createdatetime;

        // 3.3 載入申請明細價格資料（TblEEC_ApplyDetailPrice）
        // 目的：計算繳費金額
        var mainDataPri = dao.GetRowList(new TblEEC_ApplyDetailPrice()
        {
            apply_no_sub = model.SearchApply.DetailApplyNo
        });

        if (mainDataPri.ToCount() > 0)
        {
            model.SearchApplyDetail.DetailPrice = new List<SearchApplyDetailPriceModel>();
            foreach (var row in mainDataPri)
            {
                var tmpObj = new SearchApplyDetailPriceModel();
                tmpObj.InjectFrom(row);
                model.SearchApplyDetail.DetailPrice.Add(tmpObj);
            }
        }
        #endregion

        #region 4. 準備套印資料
        // 使用 Hashtable 儲存所有要替換的佔位符與對應的值
        var objects = new Hashtable();

        // 4.1 申請人資訊
        objects["APPLYNAME"] = mainDataMst.user_name;  // 申請人姓名

        // 出生日期（轉換為民國年）
        // 範例：19900101 -> 民國 79 年 01 月 01 日
        objects["BIRYEAR"] = mainDataMst.user_birthday.Substring(0, 4).TOInt32() - 1911;
        objects["BIRMONTH"] = mainDataMst.user_birthday.Substring(4, 2);
        objects["BIRDAYS"] = mainDataMst.user_birthday.Substring(6, 2);

        // 4.2 繳費日期（轉換為民國年）
        // 範例：2024-01-15 12:30:00 -> 民國 113 年 01 月 15 日
        var payDate = Convert.ToDateTime(model.SearchApplyDetail.payed_datetime).ToString("yyyyMMdd");
        objects["PAYYEAR"] = payDate.Substring(0, 4).TOInt32() - 1911;
        objects["PAYMONTH"] = payDate.Substring(4, 2);
        objects["PAYDAYS"] = payDate.Substring(6, 2);

        // 4.3 繳費金額（計算總金額並轉換為千分位格式）
        // 範例：1500 -> 1,500
        var payMoney = model.SearchApplyDetail.DetailPrice.Select(m => m.price.TOInt32()).Sum();
        objects["PAYMONEY"] = payMoney.TOTranThousandString();

        // 4.4 當前日期（轉換為民國年）
        // 範例：2024-01-15 -> 民國 113 年 01 月 15 日
        var nowDate = DateTime.Now.ToString("yyyyMMdd");
        objects["CYEAR"] = nowDate.Substring(0, 4).TOInt32() - 1911;
        objects["CMONTH"] = nowDate.Substring(4, 2);
        objects["CDAYS"] = nowDate.Substring(6, 2);
        #endregion

        #region 5. 載入 Word 模板並替換佔位符
        // 使用 Xceed.Words.NET (DocX) 載入 Word 模板
        DocX document = DocX.Load(TemplatePath);

        // 逐一替換所有佔位符
        // 範例：$APPLYNAME$ -> 王小明
        foreach (var item in objects.Keys)
        {
            string placeholder = "$" + item + "$";  // 佔位符格式：$KEY$
            string value = objects[item].TONotNullString();  // 取得對應的值（NULL 轉空字串）
            document.ReplaceText(placeholder, value);
        }
        #endregion

        #region 6. Word 轉 HTML 轉 PDF
        // 6.1 Word 轉 HTML
        // 產生暫存檔名（包含申請單號與時間戳記，避免檔名衝突）
        // 範例：A1130115001tmp240115123045123456
        string tmpFileName = tmpFolder + model.SearchApplyDetail.apply_no + "tmp" +
                            DateTime.Now.ToString("yyMMddHHmmssffffff");

        // 呼叫 SaveAndConvertHTML 方法：
        // 1. 儲存 Word 檔案
        // 2. 轉換為 HTML
        // 3. 回傳 HTML 字串
        var pHtml = this.SaveAndConvertHTML(document, tmpFileName);

        // 6.2 HTML 轉 PDF
        // 使用 Turbo.ReportTK.PDF.HtmlPDF 將 HTML 轉換為 PDF
        byte[] arrBytes = this.Convert_Html2Pdf(pHtml);

        // 6.3 加密 PDF
        // 使用 iTextSharp 加密 PDF
        // 使用者密碼（開啟密碼）：身分證字號
        // 擁有者密碼（權限密碼）：固定密碼 "Turbo@13141806"
        // 權限：允許列印
        arrBytes = this.AddPasswordToPdf(arrBytes,
            model.SearchApplyDetail.user_idno, "Turbo@13141806");
        #endregion

        #region 7. 記錄 LOG
        // 記錄使用者操作 LOG
        // 參數：
        // 1. 身分證字號
        // 2. 姓名
        // 3. 登入類型（+3 表示列印操作）
        // 4. 狀態（LoginSuccess）
        // 5. IP 位址
        // 6. 功能路徑
        // 7. 操作說明
        FrontDAO.FrontLOG(
            model.SearchApplyDetail.user_idno,
            model.SearchApplyDetail.user_name,
            (FrontDAO.em_lType)model.UserLoginTab.TOInt32() + 3,
            FrontDAO.em_lStatus.LoginSuccess,
            HttpContext.Request.UserHostAddress,
            "Home/SearchGridDetailPrint01",
            "進度查詢-列印-電子病歷服務平台繳費證明_亞東");
        #endregion

        #region 8. 回傳 PDF 檔案
        // 使用 File() 方法回傳 PDF 檔案供使用者下載
        // 參數：
        // 1. 檔案內容（byte[]）
        // 2. MIME 類型（application/pdf）
        // 3. 檔案名稱（申請單號 + 時間戳記 + 檔案說明.pdf）
        return File(arrBytes, "application/pdf",
            model.SearchApplyDetail.apply_no +
            DateTime.Now.ToString("yyyyMMddHHmmssffffff") +
            "電子病歷服務平台繳費證明_亞東.pdf");
        #endregion
    }
}
```

**程式碼說明：**

1. **ModelState.Clear()**：清除模型狀態，避免驗證錯誤影響後續處理
2. **ValueInjecter**：使用 ValueInjecter 套件複製物件屬性，避免手動逐一賦值
3. **民國年轉換**：西元年 - 1911 = 民國年（例如：2024 - 1911 = 113）
4. **千分位格式**：使用 `TOTranThousandString()` 方法將數字轉換為千分位格式（例如：1500 -> 1,500）
5. **暫存檔名**：使用申請單號 + 時間戳記（精確到百萬分之一秒）避免檔名衝突
6. **PDF 加密**：使用者密碼為身分證字號，確保只有申請人可以開啟 PDF
7. **LOG 記錄**：記錄使用者操作，包含身分證字號、姓名、IP 位址、操作說明等
8. **File() 方法**：ASP.NET MVC 提供的方法，用於回傳檔案供使用者下載

### 1.3 SaveAndConvertHTML Word 轉 HTML

**功能說明：**

此方法負責將 DocX 物件轉換為 HTML 字串，流程如下：

1. 儲存 DocX 物件為 Word 檔案（.docx）
2. 呼叫 ParseDOCX 方法將 Word 檔案轉換為 HTML
3. 將 HTML 字串寫入檔案（.html）
4. 回傳 HTML 字串

```csharp
/// <summary>
/// 傳入 DocX 物件後，轉成 HTML 字串回傳
/// </summary>
/// <param name="docx">DocX 物件（已載入模板並替換佔位符）</param>
/// <param name="path">儲存路徑（不含副檔名）</param>
/// <returns>HTML 字串</returns>
private string SaveAndConvertHTML(DocX docx, string path)
{
    // 定義檔案路徑
    var wordPath = path + ".docx";  // Word 檔案路徑
    var htmlPath = path + ".html";  // HTML 檔案路徑
    var pdf_Path = path + ".pdf";   // PDF 檔案路徑（未使用）

    // 1. 儲存成 Word 檔
    docx.SaveAs(wordPath);

    // 2. 轉換程序 - 將 Word 檔 轉換成 Html
    var fileInfo = new FileInfo(wordPath);
    string fullFilePath = fileInfo.FullName;
    string htmlText = string.Empty;

    try
    {
        // 呼叫 ParseDOCX 方法進行轉換
        htmlText = ParseDOCX(fileInfo);
    }
    catch (OpenXmlPackageException e)
    {
        // 處理 Invalid Hyperlink 錯誤
        // 當 Word 文件中包含無效的超連結時，會拋出此例外
        // 解決方法：
        // 1. 讀取 Word 檔案為 byte[]
        // 2. 使用 MemoryStream 開啟
        // 3. 移除無效的超連結關係
        // 4. 重新儲存 Word 檔案
        // 5. 再次呼叫 ParseDOCX 方法

        // （此處省略詳細程式碼，實際專案中應實作完整的錯誤處理）
        LOG.Error("Word 轉 HTML 失敗（Invalid Hyperlink）", e);
        throw;
    }

    // 3. 寫入 HTML 檔案
    var writer = System.IO.File.CreateText(htmlPath);
    writer.WriteLine(htmlText);
    writer.Dispose();

    // 4. 回傳 HTML 字串
    return htmlText;
}
```

**程式碼說明：**

1. **檔案路徑**：定義 Word、HTML、PDF 三種檔案的路徑（使用相同的檔名，不同的副檔名）
2. **SaveAs**：將 DocX 物件儲存為 Word 檔案
3. **ParseDOCX**：呼叫 ParseDOCX 方法將 Word 檔案轉換為 HTML
4. **錯誤處理**：處理 Invalid Hyperlink 錯誤（Word 文件中包含無效的超連結）
5. **寫入檔案**：將 HTML 字串寫入檔案（供除錯使用）
6. **回傳 HTML**：回傳 HTML 字串供後續轉換為 PDF

### 1.4 ParseDOCX Word 文件解析

**功能說明：**

此方法是 Word 轉 HTML 的核心，使用 OpenXmlPowerTools 函式庫進行轉換。主要功能包含：

1. 讀取 Word 檔案為 byte[]
2. 使用 MemoryStream 開啟 Word 文件
3. 設定 HTML 轉換參數
4. 處理圖片（轉換為 Base64 編碼）
5. 執行轉換並回傳 HTML 字串

```csharp
/// <summary>
/// 解析 Word 文件並轉換為 HTML
/// 使用 OpenXmlPowerTools 函式庫
/// </summary>
/// <param name="fileInfo">Word 檔案資訊</param>
/// <returns>HTML 字串</returns>
private string ParseDOCX(FileInfo fileInfo)
{
    try
    {
        // 1. 讀取 Word 檔案為 byte[]
        byte[] byteArray = System.IO.File.ReadAllBytes(fileInfo.FullName);

        using (MemoryStream memoryStream = new MemoryStream())
        {
            // 2. 將 byte[] 寫入 MemoryStream
            memoryStream.Write(byteArray, 0, byteArray.Length);

            // 3. 使用 WordprocessingDocument 開啟 Word 文件
            using (WordprocessingDocument wDoc = WordprocessingDocument.Open(memoryStream, true))
            {
                int imageCounter = 0;  // 圖片計數器

                // 4. 取得頁面標題（從 Word 文件屬性中取得）
                var pageTitle = fileInfo.FullName;
                var part = wDoc.CoreFilePropertiesPart;
                if (part != null)
                    pageTitle = (string)part.GetXDocument().Descendants(DC.title).FirstOrDefault()
                                ?? fileInfo.FullName;

                // 5. 設定 HTML 轉換參數
                WmlToHtmlConverterSettings settings = new WmlToHtmlConverterSettings()
                {
                    AdditionalCss = "body { }",  // 額外的 CSS 樣式
                    PageTitle = pageTitle,  // 頁面標題
                    FabricateCssClasses = true,  // 自動產生 CSS 類別
                    CssClassPrefix = "pt-",  // CSS 類別前綴
                    RestrictToSupportedLanguages = false,  // 不限制語言
                    RestrictToSupportedNumberingFormats = false,  // 不限制編號格式

                    // 6. 圖片處理器（將圖片轉換為 Base64 編碼）
                    ImageHandler = imageInfo =>
                    {
                        ++imageCounter;  // 圖片計數器 +1

                        // 6.1 取得圖片格式
                        string extension = imageInfo.ContentType.Split('/')[1].ToLower();
                        ImageFormat imageFormat = null;

                        // 6.2 根據圖片格式設定 ImageFormat
                        if (extension == "png")
                            imageFormat = ImageFormat.Png;
                        else if (extension == "gif")
                            imageFormat = ImageFormat.Gif;
                        else if (extension == "bmp")
                            imageFormat = ImageFormat.Bmp;
                        else if (extension == "jpeg")
                            imageFormat = ImageFormat.Jpeg;
                        else if (extension == "tiff")
                        {
                            // TIFF 格式轉換為 GIF（因為瀏覽器不支援 TIFF）
                            extension = "gif";
                            imageFormat = ImageFormat.Gif;
                        }
                        else
                            imageFormat = ImageFormat.Jpeg;  // 預設使用 JPEG

                        // 6.3 將圖片轉換為 Base64 字串
                        string base64 = null;
                        try
                        {
                            using (MemoryStream ms = new MemoryStream())
                            {
                                // 將圖片儲存到 MemoryStream
                                imageInfo.Bitmap.Save(ms, imageFormat);

                                // 轉換為 byte[]
                                var ba = ms.ToArray();

                                // 轉換為 Base64 字串
                                base64 = System.Convert.ToBase64String(ba);
                            }
                        }
                        catch (System.Runtime.InteropServices.ExternalException)
                        {
                            // 圖片轉換失敗，回傳 null
                            return null;
                        }

                        // 6.4 取得圖片的 MIME 類型
                        ImageFormat format = imageInfo.Bitmap.RawFormat;
                        ImageCodecInfo codec = ImageCodecInfo.GetImageDecoders()
                            .First(c => c.FormatID == format.Guid);
                        string mimeType = codec.MimeType;

                        // 6.5 產生 Data URI（data:image/png;base64,iVBORw0KGgo...）
                        string imageSource = string.Format("data:{0};base64,{1}", mimeType, base64);

                        // 6.6 產生 <img> 標籤
                        XElement img = new XElement(Xhtml.img,
                            new XAttribute(NoNamespace.src, imageSource),  // src 屬性（Data URI）
                            imageInfo.ImgStyleAttribute,  // style 屬性（寬度、高度等）
                            imageInfo.AltText != null ?   // alt 屬性（替代文字）
                                new XAttribute(NoNamespace.alt, imageInfo.AltText) : null);

                        return img;
                    }
                };

                // 7. 執行轉換（Word -> HTML）
                XElement htmlElement = WmlToHtmlConverter.ConvertToHtml(wDoc, settings);

                // 8. 產生完整的 HTML 文件（包含 DOCTYPE）
                var html = new XDocument(
                    new XDocumentType("html", null, null, null),  // <!DOCTYPE html>
                    htmlElement);

                // 9. 轉換為字串（不格式化，避免額外的空白字元）
                var htmlString = html.ToString(SaveOptions.DisableFormatting);

                return htmlString;
            }
        }
    }
    catch (Exception ex)
    {
        LOG.Debug("ParseDOCX() Error: " + ex.Message);
        return "";
    }
}
```

**程式碼說明：**

1. **MemoryStream**：使用 MemoryStream 避免直接操作檔案，提升效能
2. **WordprocessingDocument**：DocumentFormat.OpenXml 提供的類別，用於開啟 Word 文件
3. **WmlToHtmlConverterSettings**：OpenXmlPowerTools 提供的設定類別
4. **ImageHandler**：圖片處理器，將 Word 中的圖片轉換為 Base64 編碼的 Data URI
5. **Data URI**：將圖片內嵌在 HTML 中，格式為 `data:image/png;base64,iVBORw0KGgo...`
6. **TIFF 轉 GIF**：因為瀏覽器不支援 TIFF 格式，所以轉換為 GIF
7. **SaveOptions.DisableFormatting**：不格式化 HTML，避免額外的空白字元影響版面

## 2. HTML 轉 PDF

### 2.1 Convert_Html2Pdf HTML 轉 PDF

**功能說明：**

此方法使用 Turbo.ReportTK.PDF 函式庫將 HTML 字串轉換為 PDF 檔案。

```csharp
/// <summary>
/// 轉換程序 - 將 HTML 轉換成 PDF
/// 使用 Turbo.ReportTK.PDF 函式庫
/// </summary>
/// <param name="theHTMLText">HTML 字串</param>
/// <returns>PDF 位元組陣列</returns>
private byte[] Convert_Html2Pdf(string theHTMLText)
{
    // 1. 設定 PDF 頁面參數
    Turbo.ReportTK.PDF.HtmlPDFOptions options = new Turbo.ReportTK.PDF.HtmlPDFOptions();

    // 1.1 設定紙張大小（A4）
    options.PageSize = System.Drawing.Printing.PaperKind.A4;

    // 1.2 設定邊界（可選）
    // options.MarginTop = 0.85;     // 上邊界（英吋）
    // options.MarginBottom = 0.85;  // 下邊界（英吋）
    // options.MarginLeft = 0.5;     // 左邊界（英吋）
    // options.MarginRight = 0.5;    // 右邊界（英吋）

    // 1.3 設定頁碼字型大小（可選）
    // options.PageInfoFontSize = 12;

    // 2. Html 轉 PDF
    // 參數：
    // 1. URL（空字串表示不從 URL 載入）
    // 2. HTML 字串
    // 3. 選項
    var hPdf = new HtmlPDF().Convert("", theHTMLText, options);

    return hPdf;
}
```

**程式碼說明：**

1. **HtmlPDFOptions**：設定 PDF 頁面參數（紙張大小、邊界、頁碼等）
2. **PageSize**：設定紙張大小（A4、Letter、Legal 等）
3. **Margin**：設定邊界（單位：英吋）
4. **Convert**：執行轉換，回傳 PDF 位元組陣列

### 2.2 AddPasswordToPdf PDF 加密

**功能說明：**

此方法使用 iTextSharp 函式庫為 PDF 檔案加密，設定開啟密碼與權限。

```csharp
/// <summary>
/// 為 PDF 加密
/// 使用 iTextSharp 函式庫
/// </summary>
/// <param name="pdfBytes">PDF 位元組陣列</param>
/// <param name="userPassword">使用者密碼（開啟密碼）</param>
/// <param name="ownerPassword">擁有者密碼（權限密碼）</param>
/// <returns>加密後的 PDF 位元組陣列</returns>
public byte[] AddPasswordToPdf(byte[] pdfBytes, string userPassword, string ownerPassword)
{
    using (MemoryStream inputPdfStream = new MemoryStream(pdfBytes))
    using (MemoryStream outputPdfStream = new MemoryStream())
    {
        // 1. 讀取 PDF 檔案
        PdfReader reader = new PdfReader(inputPdfStream);

        // 2. 加密 PDF
        // 參數：
        // 1. PdfReader（PDF 讀取器）
        // 2. OutputStream（輸出串流）
        // 3. strength（加密強度，true = 128-bit, false = 40-bit）
        // 4. userPassword（使用者密碼，用於開啟 PDF）
        // 5. ownerPassword（擁有者密碼，用於設定權限）
        // 6. permissions（權限，例如：ALLOW_PRINTING、ALLOW_COPY 等）
        PdfEncryptor.Encrypt(reader, outputPdfStream, true,
            userPassword, ownerPassword, PdfWriter.ALLOW_PRINTING);

        // 3. 回傳加密後的 PDF 位元組陣列
        return outputPdfStream.ToArray();
    }
}
```

**程式碼說明：**

1. **PdfReader**：讀取 PDF 檔案
2. **PdfEncryptor.Encrypt**：加密 PDF 檔案
3. **userPassword**：使用者密碼（開啟密碼），使用者需要輸入此密碼才能開啟 PDF
4. **ownerPassword**：擁有者密碼（權限密碼），用於設定 PDF 的權限（列印、複製、修改等）
5. **ALLOW_PRINTING**：允許列印（其他權限包含 ALLOW_COPY、ALLOW_MODIFY_CONTENTS 等）
6. **128-bit 加密**：使用 128-bit 加密強度（比 40-bit 更安全）

**權限常數：**

```csharp
PdfWriter.ALLOW_PRINTING           // 允許列印
PdfWriter.ALLOW_MODIFY_CONTENTS    // 允許修改內容
PdfWriter.ALLOW_COPY               // 允許複製
PdfWriter.ALLOW_MODIFY_ANNOTATIONS // 允許修改註解
PdfWriter.ALLOW_FILL_IN            // 允許填寫表單
PdfWriter.ALLOW_SCREENREADERS      // 允許螢幕閱讀器
PdfWriter.ALLOW_ASSEMBLY           // 允許組合
PdfWriter.ALLOW_DEGRADED_PRINTING  // 允許低品質列印
```

**使用範例：**

```csharp
// 範例 1：只允許列印
PdfEncryptor.Encrypt(reader, outputPdfStream, true,
    "user123", "owner456", PdfWriter.ALLOW_PRINTING);

// 範例 2：允許列印與複製
PdfEncryptor.Encrypt(reader, outputPdfStream, true,
    "user123", "owner456",
    PdfWriter.ALLOW_PRINTING | PdfWriter.ALLOW_COPY);

// 範例 3：允許所有權限
PdfEncryptor.Encrypt(reader, outputPdfStream, true,
    "user123", "owner456",
    PdfWriter.ALLOW_PRINTING | PdfWriter.ALLOW_COPY |
    PdfWriter.ALLOW_MODIFY_CONTENTS | PdfWriter.ALLOW_FILL_IN);
```

## 3. 病歷下載功能

### 3.1 SearchGridDetailDownload 病歷下載

**功能說明：**

此功能負責下載病歷 PDF 檔案，支援兩種來源：

1. **醫院 API 提供的病歷**：從醫院 API 取得病歷 PDF（可能經過 AES 加密）
2. **一般 EEC 病歷**：從資料庫取得病歷 HTML，轉換為 PDF

**檔案位置：** `Controllers/HomeController.cs`

#### 3.1.1 病歷下載流程圖

```
病歷下載流程：

1. 檢查申請單號
    ↓
2. 載入申請明細資料
    ↓
3. 判斷病歷來源
    ├─→ 醫院 API 病歷
    │       ↓
    │   3.1 讀取加密的 PDF 檔案
    │       ↓
    │   3.2 AES 解密
    │       ↓
    │   3.3 回傳 PDF
    │
    └─→ 一般 EEC 病歷
            ↓
        3.4 從資料庫取得 HTML
            ↓
        3.5 HTML 轉 PDF
            ↓
        3.6 回傳 PDF
    ↓
4. 記錄下載次數
    ↓
5. 記錄 LOG
    ↓
6. 回傳 PDF 檔案
```

#### 3.1.2 醫院 API 病歷下載（加密檔案）

```csharp
// 醫院 API 病歷下載（亞東醫院、遠東醫院等）
if (mainData.hospital_code.TONotNullString() != "")
{
    // 取得醫院 API 設定
    var findHospApi = dao.GetRowList(new TblEEC_Hospital_Api()
    {
        hospital_code = mainData.hospital_code
    });

    // 檢查是否有下載 API
    var tmpList = findHospApi.Where(x => x.hospital_apikey == "A3").ToList();
    if (tmpList.Any())
    {
        // 取得系統設定（病歷檔案路徑）
        var getSETUP = dao.GetRow(new TblSETUP() { setup_key = "HIS_FILE_PATH" });

        if (getSETUP != null)
        {
            // 組合檔案路徑
            var hisPath = getSETUP.setup_val.TONotNullString() +
                         mainData.ec_fileName.TONotNullString();

            // 檢查檔案是否存在
            if (!System.IO.File.Exists(hisPath))
            {
                sm.LastErrorMessage = "無法取得病歷！";
                return rtn;
            }

            // 讀取加密的 PDF 檔案
            Byte[] EncryptPDF = System.IO.File.ReadAllBytes(hisPath);

            // AES 解密
            // 參數：
            // 1. Base64 編碼的加密資料
            // 2. AES 金鑰（16 bytes）
            // 3. AES IV（16 bytes）
            string Decryptstring = AesCrypto.AesDecrypt(
                Convert.ToBase64String(EncryptPDF),
                "pQ2azF4XY8R4BcgQ",  // AES 金鑰
                "FekVt9gzVUMYdpKC"); // AES IV

            // 將解密後的 Base64 字串轉換為 byte[]
            byte[] DecryptPDFBYTE = Convert.FromBase64String(Decryptstring);

            // 記錄下載次數
            this.HisDownloadCountAdd(mainData.keyid, mainData.download_count, model);

            // 回傳 PDF 檔案
            return File(DecryptPDFBYTE, "application/pdf", "病歷下載.pdf");
        }
    }
}
```

**程式碼說明：**

1. **hospital_code**：醫院代碼（例如：亞東醫院、遠東醫院）
2. **hospital_apikey = "A3"**：下載 API 的識別碼
3. **HIS_FILE_PATH**：病歷檔案儲存路徑（從系統設定取得）
4. **ec_fileName**：病歷檔案名稱
5. **AesCrypto.AesDecrypt**：AES 解密方法
6. **AES 金鑰與 IV**：固定的金鑰與 IV（應從設定檔讀取，避免硬編碼）
7. **HisDownloadCountAdd**：記錄下載次數（用於統計）

#### 3.1.3 一般 EEC 病歷下載（HTML 轉 PDF）

```csharp
// 一般 EEC 病歷下載
else
{
    // 從資料庫取得病歷 HTML
    var getApiData = dao.GetRow(new TblEEC_ApplyDetailPrice_ApiData()
    {
        master_keyid = mainData.keyid
    });

    if (getApiData == null)
    {
        sm.LastErrorMessage = "尚未取得病歷！";
        return rtn;
    }

    // 檢查 HTML 是否存在
    if (getApiData.Report_HTML.TONotNullString() == "")
    {
        sm.LastErrorMessage = "尚未取得病歷！";
        return rtn;
    }

    // 準備轉換參數
    model.TempDatas = new Hashtable();
    model.TempDatas.Add("RptId", "EEC_HTML_ReportTo_PDF");
    model.TempDatas.Add("Key", mainData.keyid.TONotNullString());

    // 記錄下載次數
    this.HisDownloadCountAdd(mainData.keyid, mainData.download_count, model);

    // 後續會呼叫 HTML 轉 PDF 的方法（程式碼省略）
}
```

**程式碼說明：**

1. **TblEEC_ApplyDetailPrice_ApiData**：病歷 API 資料表
2. **Report_HTML**：病歷 HTML 內容
3. **TempDatas**：暫存資料（用於傳遞參數）
4. **RptId**：報表識別碼（用於識別報表類型）

### 3.2 HisDownloadCountAdd 記錄下載次數

```csharp
/// <summary>
/// 記錄病歷下載次數
/// </summary>
/// <param name="keyid">明細價格 keyid</param>
/// <param name="download_count">目前下載次數</param>
/// <param name="model">ViewModel</param>
private void HisDownloadCountAdd(int keyid, int download_count, HomeViewModel model)
{
    FrontDAO dao = new FrontDAO();

    // 更新下載次數（+1）
    var resUpd = dao.Update(
        new TblEEC_ApplyDetailPrice()
        {
            download_count = download_count + 1
        },
        new TblEEC_ApplyDetailPrice()
        {
            keyid = keyid
        }
    );
}
```

**程式碼說明：**

1. **download_count**：下載次數（每次下載 +1）
2. **Update**：更新資料表（TblEEC_ApplyDetailPrice）

## 4. 總結

本文件詳細說明了 EECOnline 系統的報表產生機制，包含：

### 4.1 Word 模板套表系統

- **模板設計**：使用 `$佔位符$` 格式
- **載入模板**：使用 Xceed.Words.NET (DocX)
- **替換佔位符**：使用 `ReplaceText` 方法
- **日期處理**：西元年轉民國年
- **金額處理**：千分位格式

### 4.2 Word 轉 HTML 轉 PDF

- **Word 轉 HTML**：使用 OpenXmlPowerTools
- **圖片處理**：轉換為 Base64 編碼的 Data URI
- **HTML 轉 PDF**：使用 Turbo.ReportTK.PDF
- **PDF 加密**：使用 iTextSharp

### 4.3 病歷下載功能

- **醫院 API 病歷**：AES 解密後回傳
- **一般 EEC 病歷**：HTML 轉 PDF 後回傳
- **下載次數統計**：記錄每次下載

### 4.4 技術堆疊

| 技術               | 用途          |
| ------------------ | ------------- |
| Xceed.Words.NET    | Word 文件處理 |
| OpenXmlPowerTools  | Word 轉 HTML  |
| Turbo.ReportTK.PDF | HTML 轉 PDF   |
| iTextSharp         | PDF 加密      |
| AesCrypto          | AES 加密/解密 |

### 4.5 安全性考量

1. **PDF 加密**：使用使用者密碼（身分證字號）保護 PDF
2. **AES 加密**：病歷檔案使用 AES 加密儲存
3. **權限控制**：只允許列印，不允許複製與修改
4. **LOG 記錄**：記錄所有下載操作

完整的程式碼範例和詳細說明請參考本文件。
