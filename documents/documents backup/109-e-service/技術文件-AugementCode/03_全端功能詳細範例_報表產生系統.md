# 衛福部人民線上申辦系統 - 全端功能詳細範例：報表產生系統

## 功能概述

本文詳細說明 e-service 系統中的報表產生機制，包含 Word 模板套表、PDF 文件產生、Excel 報表匯出等功能。系統使用多種文件處理技術，提供完整的報表產製解決方案。

## 報表產生技術架構

```
報表產生流程：

資料查詢
    ↓
資料處理與格式化
    ↓
選擇報表類型
    ├─→ Word 模板套表 (DocX)
    │       ↓
    │   Word 文件產生
    │       ↓
    │   轉換為 PDF (Spire.Doc)
    │
    ├─→ Excel 報表 (NPOI)
    │       ↓
    │   Excel 文件產生
    │
    └─→ PDF 直接產生 (iTextSharp)
            ↓
        PDF 文件產生
    ↓
檔案儲存/下載
```

## 1. Word 模板套表系統

### 1.1 Word 模板設計

**模板位置：** `ES/Sample/apply001008.docx`

#### 1.1.1 模板佔位符設計

```
Word 模板中使用 $ 符號包圍的佔位符：

基本資訊：
- $APP_ID$        案件編號
- $NAME$          申請人姓名
- $ENAME$         英文姓名
- $IDN$           身分證號
- $TEL$           電話
- $EMAIL$         電子郵件
- $ADDR$          地址
- $APPLY_DATE$    申請日期

表格資料：
- 使用 Word 表格結構
- 程式動態新增表格列
- 支援多筆明細資料
```

### 1.2 Word 文件處理實作

**檔案位置：** `ES/Controllers/AJAXController.cs`

#### 1.2.1 載入模板並替換欄位

```csharp
/// <summary>
/// 產生申請書 Word 文件
/// 使用 DocX 處理 Word 模板
/// </summary>
/// <param name="APP_ID">案件編號</param>
/// <returns>Word 文件位元組陣列</returns>
public byte[] GenerateApplyFormWord(string APP_ID)
{
    byte[] buffer = null;

    try
    {
        // 取得案件資料
        ApplyDAO dao = new ApplyDAO();
        var apply = dao.GetApply_001008(APP_ID);
        var meList = dao.GetApply_001008_MeList(APP_ID);

        // 載入 Word 模板
        string templatePath = Server.MapPath("~/Sample/apply001008.docx");

        using (MemoryStream ms = new MemoryStream())
        {
            using (DocX doc = DocX.Load(templatePath))
            {
                // 替換基本欄位
                doc.ReplaceText("$APP_ID$", apply.APP_ID ?? "");
                doc.ReplaceText("$NAME$", apply.NAME ?? "");
                doc.ReplaceText("$ENAME$", apply.ENAME ?? "");
                doc.ReplaceText("$IDN$", apply.IDN ?? "");
                doc.ReplaceText("$TEL$", apply.TEL ?? "");
                doc.ReplaceText("$EMAIL$", apply.EMAIL ?? "");
                
                // 組合地址
                string fullAddr = (apply.ADDR_ZIP_ADDR ?? "") + 
                                 (apply.ADDR_ZIP_DETAIL ?? "");
                doc.ReplaceText("$ADDR$", fullAddr);

                // 處理日期（轉換為民國年）
                if (apply.APPLY_DATE.HasValue)
                {
                    string twDate = Commons.HelperUtil.TransAdToTwYear(
                        apply.APPLY_DATE.Value.ToString("yyyy/MM/dd"));
                    doc.ReplaceText("$APPLY_DATE$", twDate);
                }

                // 處理表格資料
                if (doc.Tables.Count > 0 && meList != null && meList.Count > 0)
                {
                    var table = doc.Tables[0];
                    
                    // 從第二列開始新增（第一列為表頭）
                    for (int i = 0; i < meList.Count; i++)
                    {
                        var row = table.InsertRow();
                        row.Cells[0].Paragraphs[0].Append((i + 1).ToString());
                        row.Cells[1].Paragraphs[0].Append(meList[i].ME_TYPE ?? "");
                        row.Cells[2].Paragraphs[0].Append(meList[i].ME_NO ?? "");
                        row.Cells[3].Paragraphs[0].Append(meList[i].ME_NAME ?? "");
                        row.Cells[4].Paragraphs[0].Append(meList[i].ME_ENAME ?? "");
                        
                        // 處理日期欄位
                        if (meList[i].ME_DATE.HasValue)
                        {
                            string dateStr = meList[i].ME_DATE.Value.ToString("yyyy/MM/dd");
                            row.Cells[5].Paragraphs[0].Append(dateStr);
                        }
                    }
                }

                // 儲存到記憶體串流
                doc.SaveAs(ms);
            }

            buffer = ms.ToArray();
        }
    }
    catch (Exception ex)
    {
        logger.Error("產生 Word 文件失敗", ex);
        throw;
    }

    return buffer;
}
```

**程式碼說明：**

1. **DocX 函式庫**：使用 DocX 處理 Word 文件（.docx 格式）
2. **佔位符替換**：使用 `ReplaceText` 方法替換模板中的佔位符
3. **動態表格**：使用 `InsertRow` 動態新增表格列
4. **日期處理**：將西元年轉換為民國年格式
5. **記憶體處理**：使用 MemoryStream 避免產生暫存檔案

### 1.3 Word 轉 PDF

#### 1.3.1 使用 Spire.Doc 轉換

```csharp
/// <summary>
/// 將 Word 文件轉換為 PDF
/// 使用 Spire.Doc 進行轉換
/// </summary>
/// <param name="APP_ID">案件編號</param>
/// <returns>PDF 檔案路徑</returns>
public string ConvertWordToPDF(string APP_ID)
{
    string pdfPath = string.Empty;

    try
    {
        // 產生 Word 文件
        byte[] wordBuffer = GenerateApplyFormWord(APP_ID);

        // 設定檔案路徑
        string downloadPath = DataUtils.GetConfig("DOWNLOAD_DOCUMENT_PATH");
        string fileName = APP_ID + "_" + DateTime.Now.ToString("yyyyMMddHHmmss");
        string wordPath = downloadPath + fileName + ".docx";
        pdfPath = downloadPath + fileName + ".pdf";

        // 儲存 Word 檔案
        System.IO.File.WriteAllBytes(wordPath, wordBuffer);

        // 使用 Spire.Doc 轉換為 PDF
        Spire.Doc.Document document = new Spire.Doc.Document();
        document.LoadFromFile(wordPath);
        document.SaveToFile(pdfPath, Spire.Doc.FileFormat.PDF);

        // 刪除暫存的 Word 檔案
        if (System.IO.File.Exists(wordPath))
        {
            System.IO.File.Delete(wordPath);
        }
    }
    catch (Exception ex)
    {
        logger.Error("Word 轉 PDF 失敗", ex);
        throw;
    }

    return pdfPath;
}
```

**程式碼說明：**

1. **Spire.Doc**：免費版本有頁數限制，商業版無限制
2. **檔案管理**：轉換完成後刪除暫存的 Word 檔案
3. **路徑設定**：從設定檔讀取下載路徑
4. **檔名處理**：加上時間戳記避免檔名衝突

## 2. Excel 報表產生系統

### 2.1 使用 NPOI 產生 Excel

**檔案位置：** `ES/Utils/ReportUtils.cs`

#### 2.1.1 DataTable 轉 Excel

```csharp
/// <summary>
/// 將 DataTable 轉換為 Excel 檔案
/// 使用 NPOI 函式庫
/// </summary>
/// <param name="SourceTable">資料來源</param>
/// <param name="Title">報表標題</param>
/// <returns>Excel 檔案串流</returns>
public static MemoryStream RenderDataTableToExcel(DataTable SourceTable, string Title)
{
    HSSFWorkbook workbook = new HSSFWorkbook();  // 建立 Excel 工作簿
    MemoryStream ms = new MemoryStream();        // 建立記憶體串流
    ISheet sheet = workbook.CreateSheet("sheet1"); // 建立工作表

    // 建立標題樣式
    ICellStyle titleStyle = workbook.CreateCellStyle();
    IFont titleFont = workbook.CreateFont();
    titleFont.FontHeightInPoints = 14;
    titleFont.Boldweight = (short)FontBoldWeight.Bold;
    titleStyle.SetFont(titleFont);
    titleStyle.Alignment = HorizontalAlignment.Center;

    // 建立表頭樣式
    ICellStyle headerStyle = workbook.CreateCellStyle();
    IFont headerFont = workbook.CreateFont();
    headerFont.Boldweight = (short)FontBoldWeight.Bold;
    headerStyle.SetFont(headerFont);
    headerStyle.FillForegroundColor = HSSFColor.Grey25Percent.Index;
    headerStyle.FillPattern = FillPattern.SolidForeground;
    headerStyle.BorderBottom = BorderStyle.Thin;
    headerStyle.BorderLeft = BorderStyle.Thin;
    headerStyle.BorderRight = BorderStyle.Thin;
    headerStyle.BorderTop = BorderStyle.Thin;

    // 建立資料樣式
    ICellStyle dataStyle = workbook.CreateCellStyle();
    dataStyle.BorderBottom = BorderStyle.Thin;
    dataStyle.BorderLeft = BorderStyle.Thin;
    dataStyle.BorderRight = BorderStyle.Thin;
    dataStyle.BorderTop = BorderStyle.Thin;

    int rowIndex = 0;

    // 第一列：標題
    if (!string.IsNullOrEmpty(Title))
    {
        IRow titleRow = sheet.CreateRow(rowIndex++);
        ICell titleCell = titleRow.CreateCell(0);
        titleCell.SetCellValue(Title);
        titleCell.CellStyle = titleStyle;
        
        // 合併標題儲存格
        sheet.AddMergedRegion(new CellRangeAddress(0, 0, 0, SourceTable.Columns.Count - 1));
    }

    // 第二列：表頭
    IRow headerRow = sheet.CreateRow(rowIndex++);
    for (int i = 0; i < SourceTable.Columns.Count; i++)
    {
        ICell cell = headerRow.CreateCell(i);
        cell.SetCellValue(SourceTable.Columns[i].ColumnName);
        cell.CellStyle = headerStyle;
    }

    // 資料列
    foreach (DataRow row in SourceTable.Rows)
    {
        IRow dataRow = sheet.CreateRow(rowIndex++);
        
        for (int i = 0; i < SourceTable.Columns.Count; i++)
        {
            ICell cell = dataRow.CreateCell(i);
            cell.SetCellValue(row[i].ToString());
            cell.CellStyle = dataStyle;
        }
    }

    // 自動調整欄寬
    for (int i = 0; i < SourceTable.Columns.Count; i++)
    {
        sheet.AutoSizeColumn(i);
    }

    // 寫入串流
    workbook.Write(ms);
    ms.Flush();
    ms.Position = 0;

    return ms;
}
```

**程式碼說明：**

1. **NPOI 函式庫**：開源的 Excel 處理函式庫，支援 .xls 和 .xlsx
2. **樣式設定**：分別設定標題、表頭、資料的樣式
3. **儲存格合併**：使用 `AddMergedRegion` 合併標題儲存格
4. **自動欄寬**：使用 `AutoSizeColumn` 自動調整欄寬
5. **記憶體串流**：直接在記憶體中產生 Excel，不需要暫存檔案

### 2.2 控制器中的 Excel 匯出

**檔案位置：** `ES/Areas/BACKMIN/Controllers/ReportController.cs`

#### 2.2.1 匯出案件統計報表

```csharp
/// <summary>
/// 匯出案件統計報表為 Excel
/// </summary>
[HttpPost]
public ActionResult GetExcel(SatisfactionScoresModel model)
{
    try
    {
        ReportAction action = new ReportAction();
        DataTable dt = null;

        // 根據報表類型查詢資料
        if (model.Table_Type == "1")
        {
            dt = action.CreateExcel(
                model.Rbl_Table, 
                model.Sdate.Remove(3, 1).Trim(), 
                model.Fdate.Remove(3, 1).Trim()
            );
        }
        else
        {
            dt = action.CreateExcel2(
                model.Rbl_Table, 
                model.Sdate.Remove(3, 1).Trim(), 
                model.Fdate.Remove(3, 1).Trim()
            );
        }

        // 產生 Excel 資料流
        MemoryStream ms = ReportUtils.RenderDataTableToExcel(dt, "案件統計報表");

        // 回傳檔案供下載
        return File(ms, "application/vnd.ms-excel", 
            "案件統計_" + DateTime.Now.ToString("yyyyMMdd") + ".xls");
    }
    catch (Exception ex)
    {
        logger.Error("匯出 Excel 失敗", ex);
        return Content("匯出失敗：" + ex.Message);
    }
}
```

**程式碼說明：**

1. **查詢資料**：根據條件查詢資料並轉換為 DataTable
2. **產生 Excel**：呼叫 ReportUtils 產生 Excel 檔案
3. **檔案下載**：使用 `File()` 方法回傳檔案
4. **MIME 類型**：設定正確的 MIME 類型讓瀏覽器識別

## 3. PDF 直接產生

### 3.1 使用 iTextSharp 產生 PDF

**檔案位置：** `ES/Utils/PayUtils.cs`

#### 3.1.1 產生繳費收據 PDF

```csharp
/// <summary>
/// 產生繳費收據 PDF
/// 使用 iTextSharp 直接產生 PDF
/// </summary>
/// <param name="dict">收據資料</param>
/// <returns>PDF 檔案串流</returns>
public static MemoryStream GetPDF2(Dictionary<string, string> dict)
{
    Document doc = new Document(PageSize.A4);
    MemoryStream ms = new MemoryStream();

    try
    {
        // 建立 PDF 寫入器
        PdfWriter pw = PdfWriter.GetInstance(doc, ms);
        pw.CloseStream = false;
        doc.Open();

        // 設定中文字型
        BaseFont bf = BaseFont.CreateFont(
            @"C:\Windows\Fonts\kaiu.ttf", 
            BaseFont.IDENTITY_H, 
            BaseFont.NOT_EMBEDDED
        );

        // 定義字型大小
        iTextSharp.text.Font font12 = new iTextSharp.text.Font(bf, 12);
        iTextSharp.text.Font font10 = new iTextSharp.text.Font(bf, 10);
        iTextSharp.text.Font fontTitle = new iTextSharp.text.Font(bf, 16);
        fontTitle.SetStyle(iTextSharp.text.Font.BOLD);

        // 標題
        Paragraph title = new Paragraph("繳費收據", fontTitle);
        title.Alignment = Element.ALIGN_CENTER;
        doc.Add(title);
        doc.Add(new Paragraph(" "));  // 空行

        // 建立表格
        PdfPTable table = new PdfPTable(2);  // 2 欄
        table.WidthPercentage = 100;
        table.SetWidths(new float[] { 30f, 70f });

        // 新增資料列
        AddTableRow(table, "案件編號", dict["APP_ID"], font10, bf);
        AddTableRow(table, "繳費金額", dict["AMOUNT"], font10, bf);
        AddTableRow(table, "繳費日期", dict["PAY_DATE"], font10, bf);
        AddTableRow(table, "交易序號", dict["TRANS_NO"], font10, bf);

        doc.Add(table);

        doc.Close();
        ms.Position = 0;
    }
    catch (Exception ex)
    {
        logger.Error("產生 PDF 失敗", ex);
        throw;
    }

    return ms;
}

/// <summary>
/// 新增表格列
/// </summary>
private static void AddTableRow(PdfPTable table, string label, string value, 
    iTextSharp.text.Font font, BaseFont bf)
{
    PdfPCell labelCell = new PdfPCell(new Phrase(label, font));
    labelCell.BackgroundColor = BaseColor.LIGHT_GRAY;
    labelCell.Padding = 5;
    table.AddCell(labelCell);

    PdfPCell valueCell = new PdfPCell(new Phrase(value, font));
    valueCell.Padding = 5;
    table.AddCell(valueCell);
}
```

**程式碼說明：**

1. **iTextSharp**：強大的 PDF 產生函式庫
2. **中文支援**：使用標楷體字型支援中文顯示
3. **表格佈局**：使用 `PdfPTable` 建立表格佈局
4. **樣式設定**：設定背景色、邊距等樣式
5. **記憶體處理**：直接在記憶體中產生 PDF

## 4. 報表下載機制

### 4.1 檔案下載控制器

**檔案位置：** `ES/Controllers/FileController.cs`

#### 4.1.1 下載申請書 PDF

```csharp
/// <summary>
/// 下載申請書 PDF
/// </summary>
/// <param name="APP_ID">案件編號</param>
[HttpGet]
public ActionResult DownloadApplyForm(string APP_ID)
{
    try
    {
        // 檢查登入狀態
        SessionModel sm = SessionModel.Get();
        if (sm == null || sm.UserInfo == null)
        {
            return RedirectToAction("Index", "Login");
        }

        // 檢查案件權限
        ApplyDAO dao = new ApplyDAO();
        var apply = dao.GetApply(APP_ID);
        
        if (apply == null || apply.ACC_NO != sm.UserInfo.Member.ACC_NO)
        {
            return Content("無權限下載此檔案");
        }

        // 取得 PDF 檔案路徑
        string pdfPath = GetApplyFormPDFPath(APP_ID);

        if (!System.IO.File.Exists(pdfPath))
        {
            // 檔案不存在，重新產生
            pdfPath = ConvertWordToPDF(APP_ID);
        }

        // 讀取檔案
        byte[] fileBytes = System.IO.File.ReadAllBytes(pdfPath);

        // 回傳檔案
        return File(fileBytes, "application/pdf", 
            "申請書_" + APP_ID + ".pdf");
    }
    catch (Exception ex)
    {
        logger.Error("下載申請書失敗", ex);
        return Content("下載失敗：" + ex.Message);
    }
}
```

**程式碼說明：**

1. **權限檢查**：確保使用者只能下載自己的申請書
2. **檔案檢查**：檢查檔案是否存在，不存在則重新產生
3. **檔案回傳**：使用 `File()` 方法回傳檔案
4. **錯誤處理**：捕捉異常並記錄日誌

## 5. 報表產生最佳實務

### 5.1 效能優化

```csharp
// 1. 使用快取避免重複產生
private static Dictionary<string, byte[]> _reportCache = 
    new Dictionary<string, byte[]>();

public byte[] GetCachedReport(string key, Func<byte[]> generator)
{
    if (!_reportCache.ContainsKey(key))
    {
        _reportCache[key] = generator();
    }
    return _reportCache[key];
}

// 2. 非同步處理大型報表
public async Task<byte[]> GenerateLargeReportAsync(string APP_ID)
{
    return await Task.Run(() => GenerateApplyFormWord(APP_ID));
}

// 3. 分批處理大量資料
public void ExportLargeDataSet(List<DataRow> data, int batchSize = 1000)
{
    for (int i = 0; i < data.Count; i += batchSize)
    {
        var batch = data.Skip(i).Take(batchSize);
        ProcessBatch(batch);
    }
}
```

### 5.2 錯誤處理

```csharp
// 統一的報表產生錯誤處理
public ActionResult GenerateReport(string reportType, string APP_ID)
{
    try
    {
        byte[] reportData = null;

        switch (reportType)
        {
            case "word":
                reportData = GenerateApplyFormWord(APP_ID);
                break;
            case "pdf":
                reportData = GenerateApplyFormPDF(APP_ID);
                break;
            case "excel":
                reportData = GenerateApplyFormExcel(APP_ID);
                break;
            default:
                return Content("不支援的報表類型");
        }

        return File(reportData, GetMimeType(reportType), 
            GetFileName(reportType, APP_ID));
    }
    catch (Exception ex)
    {
        logger.Error($"產生報表失敗：{reportType}, {APP_ID}", ex);
        return Content("報表產生失敗，請稍後再試");
    }
}
```

## 6. 總結

e-service 系統的報表產生機制提供了完整的解決方案：

### 6.1 技術特色
- 支援多種文件格式（Word、PDF、Excel）
- 模板化設計便於維護
- 記憶體處理提升效能
- 完整的錯誤處理機制

### 6.2 功能特色
- Word 模板套表
- 動態表格處理
- 文件格式轉換
- 批次報表產生

### 6.3 安全性特色
- 權限檢查
- 檔案存取控制
- 暫存檔案清理
- 操作日誌記錄

這套報表系統為團隊提供了完整的文件處理能力，滿足政府線上申辦系統的各種報表需求。

