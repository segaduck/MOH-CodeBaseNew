# 管理員操作指南：更新使用身分證字號作為帳號的會員資料

## 功能特色

本指南提供以下功能：

### ✨ 彈性的帳號命名方式

- **手動指定新帳號**：會員可要求使用特定帳號（如 `john_wang`、`mary_lee`）
- **自動產生新帳號**：系統自動產生帳號（如 `MEM100001`、`MEM100002`）
- **混合模式**：部分帳號手動指定，其他自動產生

### 🔒 完整的安全機制

- **交易保護**：所有更新使用交易，確保完整相依性
- **多重驗證**：帳號格式、重複性、身分證格式等多重檢查
- **錯誤處理**：完整的錯誤處理和回滾機制
- **軟刪除**：保留舊記錄，可追溯歷史

### 📊 支援單筆與批次更新

- **單筆更新**：適合個別會員要求
- **批次更新**：適合大量帳號遷移
- **進度追蹤**：批次更新可追蹤處理進度

## 問題說明

### 安全政策變更

根據新的資訊安全政策，**會員帳號（ACC_NO）不得使用身分證字號（IDN）或統一編號**。

**原因：**

1. 身分證字號屬於敏感個人資料
2. 使用身分證字號作為帳號增加個資外洩風險
3. 不符合個人資料保護法的最小化原則

### 系統現況

#### 1. 新會員註冊時的帳號規則

系統在會員註冊時已實施嚴格的帳號驗證（`ES/DataLayers/LoginDAO.cs` 第 154-158 行）：

```csharp
// 個人會員資料檢核
public string ChkMemberInfo(LoginDetailModel detail)
{
    string Msg = "";

    if (detail.ACC_NO.TONotNullString() == "")
    {
        Msg += "帳號未填 \n";
    }
    if (Msg.Length > 1) { return Msg; }

    // 檢查帳號是否為身分證格式
    if (Regex.IsMatch(detail.ACC_NO, @"^[A-Za-z](1|2)\d{8}$"))
    {
        Msg += "帳號不得為身份證編號/居留證號格式 \n";
    }
    // ... 其他驗證
}
```

**帳號格式規則（`ES/Models/MemberModels.cs` 第 245-250 行）：**

```csharp
[Remote("CheckAccountExists", "AJAX", ErrorMessage = "帳號已存在")]
[Required(ErrorMessage = "請輸入帳號")]
[StringLength(20, MinimumLength = 6, ErrorMessage = "帳號至少6個字元，最多20個字元")]
[RegularExpression(@"^(?!.*[A-Za-z]+[0-9]{9})[A-Za-z]+[A-Za-z0-9_]*$", ErrorMessage = "帳號格式錯誤/帳號不得為身分證")]
[Display(Name = "帳號")]
public override string Account { get; set; }
```

**新會員註冊的帳號規則：**

- ✓ 長度：6-20 個字元
- ✓ 格式：必須以英文字母開頭，可包含英文、數字、底線
- ✓ 限制：**不得為身分證格式**（1 個英文字母 + 1 或 2 + 8 個數字）
- ✓ 唯一性：帳號不得重複

**驗證流程：**

1. **前端驗證**：使用 RegularExpression 和 Remote 驗證
2. **後端驗證**：ChkMemberInfo() 檢查帳號格式
3. **資料庫驗證**：ChkACC_NO() 檢查帳號是否重複

#### 2. 登入時的安全檢查

系統在會員登入時會檢查此問題（`ES/Controllers/LoginController.cs` 第 1012-1014 行）：

```csharp
if (Convert.ToString(userInfo.Member.ACC_NO) == Convert.ToString(userInfo.Member.IDN))
{
    result.message += "因應資訊安全，帳號不得同身份證字號/統一編號，請填寫服務信箱申請變更。\n";
}
```

#### 3. 會員資料完整性檢查

系統在會員資料檢查時也會驗證（`ES/DataLayers/LoginDAO.cs` 第 876-888 行）：

```csharp
public bool CheckMemberData(LoginUserInfo model)
{
    var result = true;
    var msg = string.Empty;
    var member = model.Member;

    // 檢查密碼是否等於帳號
    if (DataUtils.Crypt256(member.ACC_NO) == member.PSWD)
    {
        msg += "請更新密碼\n";
    }

    // 檢查帳號是否等於身分證字號
    if (Convert.ToString(member.ACC_NO) == Convert.ToString(member.IDN))
    {
        msg += "帳號不得同為身份證字號或統一編號\n";
    }
    // ...
}
```

### 問題來源

雖然系統已實施上述驗證機制，但**部分舊會員資料**（在實施此政策前註冊）仍存在 `ACC_NO = IDN` 的情況，需要管理員協助更新。

**可能的原因：**

1. 早期系統允許使用身分證字號作為帳號
2. 資料移轉時未進行驗證
3. 手動建立的測試帳號

## 資料表結構

### MEMBER 會員主檔

| 欄位名稱 | 資料型別      | 說明                | 備註                         |
| -------- | ------------- | ------------------- | ---------------------------- |
| ACC_NO   | NVARCHAR(50)  | 帳號（主鍵）        | **不得與 IDN 相同**          |
| PSWD     | NVARCHAR(100) | 密碼                | SHA-256 加密儲存             |
| IDN      | NVARCHAR(20)  | 身分證字號/統一編號 | 10 碼（個人）或 8 碼（公司） |
| NAME     | NVARCHAR(100) | 中文姓名            |                              |
| MAIL     | NVARCHAR(200) | Email               |                              |
| MOBILE   | NVARCHAR(20)  | 手機                |                              |
| DEL_MK   | NVARCHAR(1)   | 刪除標記            | 'Y'=已刪除, 'N'=正常         |

### 關聯資料表

以下資料表使用 `ACC_NO` 作為外鍵，更新時需一併處理：

1. **LOGIN_LOG** - 登入記錄
2. **APPLY** - 申請主檔
3. **APPLY_PAY** - 繳費記錄
4. **MESSAGE** - 訊息記錄
5. **MAIL_LOG** - 郵件記錄

## 操作步驟

### 步驟 1：查詢問題帳號

#### 1.1 查詢所有 ACC_NO = IDN 的會員

```sql
-- 查詢所有帳號等於身分證字號的會員（未刪除）
SELECT
    ACC_NO AS 帳號,
    IDN AS 身分證字號,
    NAME AS 姓名,
    MAIL AS Email,
    MOBILE AS 手機,
    LAST_LOGINDATE AS 最後登入時間,
    ADD_TIME AS 建立時間,
    UPD_TIME AS 更新時間
FROM MEMBER
WHERE 1=1
    AND ISNULL(DEL_MK, 'N') = 'N'  -- 未刪除
    AND ACC_NO = IDN               -- 帳號等於身分證字號
    AND LEN(IDN) = 10              -- 身分證字號長度為 10
ORDER BY LAST_LOGINDATE DESC;
```

**預期結果：** 列出所有需要更新的會員清單

#### 1.2 統計問題帳號數量

```sql
-- 統計需要更新的會員數量
SELECT
    COUNT(*) AS 需要更新的會員數量,
    COUNT(CASE WHEN LAST_LOGINDATE IS NOT NULL THEN 1 END) AS 曾經登入過的會員,
    COUNT(CASE WHEN LAST_LOGINDATE IS NULL THEN 1 END) AS 從未登入過的會員
FROM MEMBER
WHERE 1=1
    AND ISNULL(DEL_MK, 'N') = 'N'
    AND ACC_NO = IDN
    AND LEN(IDN) = 10;
```

### 步驟 2：查詢特定會員的所有關聯資料

**用途：** 在更新前，確認該會員在系統中的所有資料範圍

```sql
-- 請將 @TARGET_IDN 替換為實際的身分證字號
DECLARE @TARGET_IDN NVARCHAR(20) = 'A123456789';  -- 替換為實際身分證字號

-- 2.1 會員基本資料
SELECT '會員基本資料' AS 資料類型, *
FROM MEMBER
WHERE ACC_NO = @TARGET_IDN;

-- 2.2 登入記錄
SELECT '登入記錄' AS 資料類型, COUNT(*) AS 記錄數量
FROM LOGIN_LOG
WHERE LOGIN_ID = @TARGET_IDN;

-- 2.3 申請案件
SELECT '申請案件' AS 資料類型,
    APPLY_NO AS 申請編號,
    SERVICE_CD AS 服務代碼,
    STATUS_CD AS 狀態,
    ADD_TIME AS 申請時間
FROM APPLY
WHERE ACC_NO = @TARGET_IDN
ORDER BY ADD_TIME DESC;

-- 2.4 繳費記錄
SELECT '繳費記錄' AS 資料類型,
    PAY_NO AS 繳費編號,
    PAY_AMT AS 金額,
    PAY_STATUS AS 狀態,
    PAY_TIME AS 繳費時間
FROM APPLY_PAY
WHERE ACC_NO = @TARGET_IDN
ORDER BY PAY_TIME DESC;

-- 2.5 訊息記錄
SELECT '訊息記錄' AS 資料類型, COUNT(*) AS 記錄數量
FROM MESSAGE
WHERE RECEIVER_ACC_NO = @TARGET_IDN;

-- 2.6 郵件記錄
SELECT '郵件記錄' AS 資料類型, COUNT(*) AS 記錄數量
FROM MAIL_LOG
WHERE ACC_NO = @TARGET_IDN;
```

### 步驟 3：產生新帳號建議

#### 3.1 新帳號命名規則建議

**重要：新帳號必須符合系統的帳號格式規則**

根據系統的帳號驗證規則（`ES/Models/MemberModels.cs`），新帳號必須符合以下條件：

1. **長度**：6-20 個字元
2. **格式**：必須以英文字母開頭，可包含英文、數字、底線（`_`）
3. **限制**：不得為身分證格式（`^[A-Za-z](1|2)\d{8}$`）
4. **唯一性**：帳號不得重複

**方案 A：使用 Email 前綴**

- 格式：`{email_prefix}` 或 `{email_prefix}_{number}`
- 範例：`john_wang` 或 `john_wang_001`
- 優點：容易記憶、有意義
- 缺點：Email 前綴可能重複、需要處理特殊字元
- 適用：少量更新、會員可自行選擇

**方案 B：使用姓名拼音 + 流水號**

- 格式：`{name_pinyin}_{number}`
- 範例：`wang_xiaoming_001`
- 優點：有意義且唯一
- 缺點：需要人工確認拼音、中文姓名轉拼音可能有誤
- 適用：少量更新、需要人工介入

**方案 C：使用 'MEM' + 6 位數流水號（強烈建議）**

- 格式：`MEM{NNNNNN}`
- 範例：`MEM100001`, `MEM100002`, `MEM100003`
- 優點：
  - ✓ 完全去識別化
  - ✓ 唯一性保證
  - ✓ 自動化產生
  - ✓ 符合系統帳號格式規則
  - ✓ 易於管理和追蹤
- 缺點：無意義（但這正是去識別化的目的）
- 適用：**批次更新、大量處理**

**建議選擇：**

- **批次更新**：使用方案 C（`MEM` + 6 位數流水號）
- **少量更新**：使用方案 A（Email 前綴）或方案 B（姓名拼音）

#### 3.2 產生新帳號的 SQL

```sql
-- 方案 C：產生 'MEM' + 6 位數流水號
-- 查詢目前最大的流水號
SELECT
    ACC_NO AS 原帳號,
    IDN AS 身分證字號,
    NAME AS 姓名,
    'MEM' + RIGHT('000000' + CAST(ROW_NUMBER() OVER (ORDER BY ADD_TIME) + 100000 AS VARCHAR), 6) AS 建議新帳號
FROM MEMBER
WHERE 1=1
    AND ISNULL(DEL_MK, 'N') = 'N'
    AND ACC_NO = IDN
    AND LEN(IDN) = 10
ORDER BY ADD_TIME;
```

**輸出範例：**
| 原帳號 | 身分證字號 | 姓名 | 建議新帳號 |
| ---------- | ---------- | ------ | ---------- |
| A123456789 | A123456789 | 王小明 | MEM100001 |
| B987654321 | B987654321 | 李小華 | MEM100002 |

### 步驟 4：更新帳號（單筆更新）

**⚠ 重要警告：**

1. 請先在**測試環境**執行並驗證
2. 建議在**離峰時段**執行
3. 執行前請先**備份資料庫**
4. 建議使用**交易（Transaction）**確保資料一致性

**⚠ 技術說明：ACC_NO 是主鍵（Primary Key）**

根據程式碼分析（`ES/Action/MemberAction.cs`）：

- **MEMBER.ACC_NO** 是主鍵（PRIMARY KEY）
- **LOGIN_LOG.LOGIN_ID** 參照 MEMBER.ACC_NO
- **APPLY.ACC_NO** 參照 MEMBER.ACC_NO（如果存在）
- **APPLY_PAY.ACC_NO** 參照 MEMBER.ACC_NO（如果存在）
- **MESSAGE.RECEIVER_ACC_NO** 參照 MEMBER.ACC_NO（如果存在）
- **MAIL_LOG.ACC_NO** 參照 MEMBER.ACC_NO（如果存在）

**重要發現：**

1. 程式碼中所有 UPDATE MEMBER 語句都使用 `WHERE ACC_NO = @ACC_NO`，但**從未**更新 ACC_NO 欄位本身
2. 這表示系統設計上將 ACC_NO 視為**不可變更的主鍵**
3. 根據程式碼分析，系統**沒有定義外鍵約束（Foreign Key Constraints）**

**兩種解決方案：**

**方案 A：INSERT 新記錄 + 軟刪除舊記錄（強烈建議）**

優點：

- ✓ 符合系統設計原則（ACC_NO 不可變更）
- ✓ 保留完整的資料歷程
- ✓ 可以回滾
- ✓ 符合系統的軟刪除設計
- ✓ 最安全的方式

缺點：

- 需要複製會員資料
- 舊記錄仍存在（軟刪除）

**方案 B：直接 UPDATE ACC_NO（僅在確認無 FK 約束時）**

優點：

- ✓ 簡單直接
- ✓ 不需要複製資料

缺點：

- ✗ 違反系統設計原則
- ✗ 如果有 FK 約束會失敗
- ✗ 無法保留歷程
- ✗ 風險較高

**本文採用方案 A（INSERT + 軟刪除）**

策略：

1. 複製舊會員資料，建立新帳號的會員記錄（INSERT）
2. 更新所有關聯資料表的 ACC_NO
3. 軟刪除舊會員記錄（UPDATE DEL_MK = 'Y'）

#### 4.1 單筆更新（手動指定新帳號）

**使用時機：** 會員主動要求變更為特定帳號

```sql
-- 單筆更新範例（手動指定新帳號）
-- 請將變數替換為實際值
DECLARE @OLD_ACC_NO NVARCHAR(50) = 'A123456789';  -- 舊帳號（身分證字號）
DECLARE @NEW_ACC_NO NVARCHAR(50) = 'john_wang';   -- 新帳號（會員要求的帳號）
DECLARE @IDN NVARCHAR(20) = 'A123456789';         -- 身分證字號（用於驗證）

-- 開始交易
BEGIN TRANSACTION;

BEGIN TRY
    -- 驗證：確認舊帳號存在且等於身分證字號
    IF NOT EXISTS (
        SELECT 1 FROM MEMBER
        WHERE ACC_NO = @OLD_ACC_NO
            AND IDN = @IDN
            AND ACC_NO = IDN
            AND ISNULL(DEL_MK, 'N') = 'N'
    )
    BEGIN
        RAISERROR('錯誤：找不到符合條件的會員資料', 16, 1);
        ROLLBACK TRANSACTION;
        RETURN;
    END

    -- 驗證：確認新帳號不存在
    IF EXISTS (SELECT 1 FROM MEMBER WHERE ACC_NO = @NEW_ACC_NO AND ISNULL(DEL_MK, 'N') = 'N')
    BEGIN
        RAISERROR('錯誤：新帳號已存在', 16, 1);
        ROLLBACK TRANSACTION;
        RETURN;
    END

    -- 1. 複製舊會員資料，建立新帳號的會員記錄
    INSERT INTO MEMBER (
        ACC_NO, PSWD, IDN, SEX_CD, BIRTHDAY, NAME, ENAME, CNT_NAME, CNT_ENAME,
        CHR_NAME, CHR_ENAME, TEL, FAX, CNT_TEL, MAIL, CITY_CD, TOWN_CD, ADDR, EADDR,
        MEDICO, MAIL_MK, CARD_TYPE, CARD_INFO, CARD_IDX, SERIALNO, MOBILE, ONAME,
        LAST_LOGINDATE, DEL_MK, UPD_TIME, UPD_FUN_CD, UPD_ACC, ADD_TIME, ADD_FUN_CD, ADD_ACC
    )
    SELECT
        @NEW_ACC_NO,  -- 使用新帳號
        PSWD, IDN, SEX_CD, BIRTHDAY, NAME, ENAME, CNT_NAME, CNT_ENAME,
        CHR_NAME, CHR_ENAME, TEL, FAX, CNT_TEL, MAIL, CITY_CD, TOWN_CD, ADDR, EADDR,
        MEDICO, MAIL_MK, CARD_TYPE, CARD_INFO, CARD_IDX, SERIALNO, MOBILE, ONAME,
        LAST_LOGINDATE, 'N',  -- 確保新記錄未刪除
        GETDATE(), 'ADMIN-ACC-UPDATE', 'ADMIN',  -- 更新資訊
        GETDATE(), 'ADMIN-ACC-UPDATE', 'ADMIN'   -- 新增資訊
    FROM MEMBER
    WHERE ACC_NO = @OLD_ACC_NO AND IDN = @IDN;

    -- 2. 更新 LOGIN_LOG 登入記錄
    UPDATE LOGIN_LOG
    SET LOGIN_ID = @NEW_ACC_NO
    WHERE LOGIN_ID = @OLD_ACC_NO;

    -- 3. 更新 APPLY 申請主檔（如果存在）
    IF OBJECT_ID('APPLY', 'U') IS NOT NULL
    BEGIN
        UPDATE APPLY
        SET ACC_NO = @NEW_ACC_NO,
            UPD_TIME = GETDATE(),
            UPD_FUN_CD = 'ADMIN-ACC-UPDATE',
            UPD_ACC = 'ADMIN'
        WHERE ACC_NO = @OLD_ACC_NO;
    END

    -- 4. 更新 APPLY_PAY 繳費記錄（如果存在）
    IF OBJECT_ID('APPLY_PAY', 'U') IS NOT NULL
    BEGIN
        UPDATE APPLY_PAY
        SET ACC_NO = @NEW_ACC_NO,
            UPD_TIME = GETDATE(),
            UPD_FUN_CD = 'ADMIN-ACC-UPDATE',
            UPD_ACC = 'ADMIN'
        WHERE ACC_NO = @OLD_ACC_NO;
    END

    -- 5. 更新 MESSAGE 訊息記錄（如果存在 RECEIVER_ACC_NO 欄位）
    IF OBJECT_ID('MESSAGE', 'U') IS NOT NULL
    BEGIN
        IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('MESSAGE') AND name = 'RECEIVER_ACC_NO')
        BEGIN
            UPDATE MESSAGE
            SET RECEIVER_ACC_NO = @NEW_ACC_NO
            WHERE RECEIVER_ACC_NO = @OLD_ACC_NO;
        END
    END

    -- 6. 更新 MAIL_LOG 郵件記錄（如果存在 ACC_NO 欄位）
    IF OBJECT_ID('MAIL_LOG', 'U') IS NOT NULL
    BEGIN
        IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('MAIL_LOG') AND name = 'ACC_NO')
        BEGIN
            UPDATE MAIL_LOG
            SET ACC_NO = @NEW_ACC_NO
            WHERE ACC_NO = @OLD_ACC_NO;
        END
    END

    -- 7. 軟刪除舊會員記錄
    UPDATE MEMBER
    SET DEL_MK = 'Y',
        DEL_TIME = GETDATE(),
        DEL_FUN_CD = 'ADMIN-ACC-UPDATE',
        DEL_ACC = 'ADMIN',
        UPD_TIME = GETDATE(),
        UPD_FUN_CD = 'ADMIN-ACC-UPDATE',
        UPD_ACC = 'ADMIN'
    WHERE ACC_NO = @OLD_ACC_NO AND IDN = @IDN;

    -- 顯示更新結果
    SELECT
        '更新成功' AS 狀態,
        @OLD_ACC_NO AS 舊帳號,
        @NEW_ACC_NO AS 新帳號,
        @IDN AS 身分證字號,
        GETDATE() AS 更新時間;

    -- 提交交易
    COMMIT TRANSACTION;
    PRINT '交易已提交';

END TRY
BEGIN CATCH
    -- 發生錯誤時回滾
    ROLLBACK TRANSACTION;

    -- 顯示錯誤訊息
    SELECT
        ERROR_NUMBER() AS 錯誤編號,
        ERROR_MESSAGE() AS 錯誤訊息,
        ERROR_LINE() AS 錯誤行號;

    PRINT '交易已回滾';
END CATCH;
```

#### 4.2 單筆更新（自動產生新帳號）

**使用時機：** 會員未指定新帳號，由系統自動產生

```sql
-- 單筆更新範例（自動產生新帳號）
-- 請將變數替換為實際值
DECLARE @OLD_ACC_NO NVARCHAR(50) = 'A123456789';  -- 舊帳號（身分證字號）
DECLARE @NEW_ACC_NO NVARCHAR(50) = NULL;          -- 新帳號（NULL = 自動產生）
DECLARE @IDN NVARCHAR(20) = 'A123456789';         -- 身分證字號（用於驗證）

-- 開始交易
BEGIN TRANSACTION;

BEGIN TRY
    -- 驗證：確認舊帳號存在且等於身分證字號
    IF NOT EXISTS (
        SELECT 1 FROM MEMBER
        WHERE ACC_NO = @OLD_ACC_NO
            AND IDN = @IDN
            AND ACC_NO = IDN
            AND ISNULL(DEL_MK, 'N') = 'N'
    )
    BEGIN
        RAISERROR('錯誤：找不到符合條件的會員資料', 16, 1);
        ROLLBACK TRANSACTION;
        RETURN;
    END

    -- 如果未指定新帳號，自動產生
    IF @NEW_ACC_NO IS NULL OR @NEW_ACC_NO = ''
    BEGIN
        -- 查詢目前最大的 MEM 流水號
        DECLARE @MAX_SEQ INT;

        SELECT @MAX_SEQ = ISNULL(MAX(CAST(SUBSTRING(ACC_NO, 4, 6) AS INT)), 100000)
        FROM MEMBER
        WHERE ACC_NO LIKE 'MEM%'
            AND LEN(ACC_NO) = 9
            AND ISNUMERIC(SUBSTRING(ACC_NO, 4, 6)) = 1;

        -- 產生新帳號
        SET @NEW_ACC_NO = 'MEM' + RIGHT('000000' + CAST(@MAX_SEQ + 1 AS VARCHAR), 6);

        PRINT '自動產生新帳號：' + @NEW_ACC_NO;
    END

    -- 驗證：確認新帳號不存在
    IF EXISTS (SELECT 1 FROM MEMBER WHERE ACC_NO = @NEW_ACC_NO AND ISNULL(DEL_MK, 'N') = 'N')
    BEGIN
        RAISERROR('錯誤：新帳號已存在', 16, 1);
        ROLLBACK TRANSACTION;
        RETURN;
    END

    -- 驗證：新帳號符合系統規則
    IF NOT (@NEW_ACC_NO LIKE '[A-Za-z]%' AND LEN(@NEW_ACC_NO) BETWEEN 6 AND 20)
    BEGIN
        RAISERROR('錯誤：新帳號不符合系統規則（6-20 個字元，以英文字母開頭）', 16, 1);
        ROLLBACK TRANSACTION;
        RETURN;
    END

    -- 驗證：新帳號不得為身分證格式
    IF @NEW_ACC_NO LIKE '[A-Za-z][12]________' AND LEN(@NEW_ACC_NO) = 10
    BEGIN
        RAISERROR('錯誤：新帳號不得為身分證格式', 16, 1);
        ROLLBACK TRANSACTION;
        RETURN;
    END

    -- 1. 複製舊會員資料，建立新帳號的會員記錄
    INSERT INTO MEMBER (
        ACC_NO, PSWD, IDN, SEX_CD, BIRTHDAY, NAME, ENAME, CNT_NAME, CNT_ENAME,
        CHR_NAME, CHR_ENAME, TEL, FAX, CNT_TEL, MAIL, CITY_CD, TOWN_CD, ADDR, EADDR,
        MEDICO, MAIL_MK, CARD_TYPE, CARD_INFO, CARD_IDX, SERIALNO, MOBILE, ONAME,
        LAST_LOGINDATE, DEL_MK, UPD_TIME, UPD_FUN_CD, UPD_ACC, ADD_TIME, ADD_FUN_CD, ADD_ACC
    )
    SELECT
        @NEW_ACC_NO,  -- 使用新帳號（手動指定或自動產生）
        PSWD, IDN, SEX_CD, BIRTHDAY, NAME, ENAME, CNT_NAME, CNT_ENAME,
        CHR_NAME, CHR_ENAME, TEL, FAX, CNT_TEL, MAIL, CITY_CD, TOWN_CD, ADDR, EADDR,
        MEDICO, MAIL_MK, CARD_TYPE, CARD_INFO, CARD_IDX, SERIALNO, MOBILE, ONAME,
        LAST_LOGINDATE, 'N',  -- 確保新記錄未刪除
        GETDATE(), 'ADMIN-ACC-UPDATE', 'ADMIN',  -- 更新資訊
        GETDATE(), 'ADMIN-ACC-UPDATE', 'ADMIN'   -- 新增資訊
    FROM MEMBER
    WHERE ACC_NO = @OLD_ACC_NO AND IDN = @IDN;

    -- 2. 更新 LOGIN_LOG 登入記錄
    UPDATE LOGIN_LOG
    SET LOGIN_ID = @NEW_ACC_NO
    WHERE LOGIN_ID = @OLD_ACC_NO;

    -- 3. 更新 APPLY 申請主檔（如果存在）
    IF OBJECT_ID('APPLY', 'U') IS NOT NULL
    BEGIN
        UPDATE APPLY
        SET ACC_NO = @NEW_ACC_NO,
            UPD_TIME = GETDATE(),
            UPD_FUN_CD = 'ADMIN-ACC-UPDATE',
            UPD_ACC = 'ADMIN'
        WHERE ACC_NO = @OLD_ACC_NO;
    END

    -- 4. 更新 APPLY_PAY 繳費記錄（如果存在）
    IF OBJECT_ID('APPLY_PAY', 'U') IS NOT NULL
    BEGIN
        UPDATE APPLY_PAY
        SET ACC_NO = @NEW_ACC_NO,
            UPD_TIME = GETDATE(),
            UPD_FUN_CD = 'ADMIN-ACC-UPDATE',
            UPD_ACC = 'ADMIN'
        WHERE ACC_NO = @OLD_ACC_NO;
    END

    -- 5. 更新 MESSAGE 訊息記錄（如果存在 RECEIVER_ACC_NO 欄位）
    IF OBJECT_ID('MESSAGE', 'U') IS NOT NULL
    BEGIN
        IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('MESSAGE') AND name = 'RECEIVER_ACC_NO')
        BEGIN
            UPDATE MESSAGE
            SET RECEIVER_ACC_NO = @NEW_ACC_NO
            WHERE RECEIVER_ACC_NO = @OLD_ACC_NO;
        END
    END

    -- 6. 更新 MAIL_LOG 郵件記錄（如果存在 ACC_NO 欄位）
    IF OBJECT_ID('MAIL_LOG', 'U') IS NOT NULL
    BEGIN
        IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('MAIL_LOG') AND name = 'ACC_NO')
        BEGIN
            UPDATE MAIL_LOG
            SET ACC_NO = @NEW_ACC_NO
            WHERE ACC_NO = @OLD_ACC_NO;
        END
    END

    -- 7. 軟刪除舊會員記錄
    UPDATE MEMBER
    SET DEL_MK = 'Y',
        DEL_TIME = GETDATE(),
        DEL_FUN_CD = 'ADMIN-ACC-UPDATE',
        DEL_ACC = 'ADMIN',
        UPD_TIME = GETDATE(),
        UPD_FUN_CD = 'ADMIN-ACC-UPDATE',
        UPD_ACC = 'ADMIN'
    WHERE ACC_NO = @OLD_ACC_NO AND IDN = @IDN;

    -- 顯示更新結果
    SELECT
        '更新成功' AS 狀態,
        @OLD_ACC_NO AS 舊帳號,
        @NEW_ACC_NO AS 新帳號,
        @IDN AS 身分證字號,
        GETDATE() AS 更新時間;

    -- 提交交易
    COMMIT TRANSACTION;
    PRINT '交易已提交';

END TRY
BEGIN CATCH
    -- 發生錯誤時回滾
    ROLLBACK TRANSACTION;

    -- 顯示錯誤訊息
    SELECT
        ERROR_NUMBER() AS 錯誤編號,
        ERROR_MESSAGE() AS 錯誤訊息,
        ERROR_LINE() AS 錯誤行號;

    PRINT '交易已回滾';
END CATCH;
```

#### 4.3 單筆更新（彈性版本：支援手動或自動）

**使用時機：** 通用版本，可手動指定或自動產生

**使用方式：**

- 如果 `@NEW_ACC_NO` 有值 → 使用指定的帳號
- 如果 `@NEW_ACC_NO` 為 NULL 或空字串 → 自動產生帳號

```sql
-- 單筆更新範例（彈性版本）
-- 請將變數替換為實際值
DECLARE @OLD_ACC_NO NVARCHAR(50) = 'A123456789';  -- 舊帳號（身分證字號）
DECLARE @NEW_ACC_NO NVARCHAR(50) = NULL;          -- 新帳號（NULL = 自動產生，或指定帳號如 'john_wang'）
DECLARE @IDN NVARCHAR(20) = 'A123456789';         -- 身分證字號（用於驗證）

-- 範例 1：自動產生新帳號
-- SET @NEW_ACC_NO = NULL;

-- 範例 2：手動指定新帳號
-- SET @NEW_ACC_NO = 'john_wang';

-- 範例 3：使用 Email 前綴
-- SET @NEW_ACC_NO = 'john_wang_001';

-- 開始交易
BEGIN TRANSACTION;

BEGIN TRY
    -- 驗證：確認舊帳號存在且等於身分證字號
    IF NOT EXISTS (
        SELECT 1 FROM MEMBER
        WHERE ACC_NO = @OLD_ACC_NO
            AND IDN = @IDN
            AND ACC_NO = IDN
            AND ISNULL(DEL_MK, 'N') = 'N'
    )
    BEGIN
        RAISERROR('錯誤：找不到符合條件的會員資料', 16, 1);
        ROLLBACK TRANSACTION;
        RETURN;
    END

    -- 如果未指定新帳號，自動產生
    IF @NEW_ACC_NO IS NULL OR @NEW_ACC_NO = ''
    BEGIN
        -- 查詢目前最大的 MEM 流水號
        DECLARE @MAX_SEQ INT;

        SELECT @MAX_SEQ = ISNULL(MAX(CAST(SUBSTRING(ACC_NO, 4, 6) AS INT)), 100000)
        FROM MEMBER
        WHERE ACC_NO LIKE 'MEM%'
            AND LEN(ACC_NO) = 9
            AND ISNUMERIC(SUBSTRING(ACC_NO, 4, 6)) = 1;

        -- 產生新帳號
        SET @NEW_ACC_NO = 'MEM' + RIGHT('000000' + CAST(@MAX_SEQ + 1 AS VARCHAR), 6);

        PRINT '自動產生新帳號：' + @NEW_ACC_NO;
    END
    ELSE
    BEGIN
        PRINT '使用指定帳號：' + @NEW_ACC_NO;
    END

    -- 驗證：確認新帳號不存在
    IF EXISTS (SELECT 1 FROM MEMBER WHERE ACC_NO = @NEW_ACC_NO AND ISNULL(DEL_MK, 'N') = 'N')
    BEGIN
        RAISERROR('錯誤：新帳號已存在', 16, 1);
        ROLLBACK TRANSACTION;
        RETURN;
    END

    -- 驗證：新帳號符合系統規則
    IF NOT (@NEW_ACC_NO LIKE '[A-Za-z]%' AND LEN(@NEW_ACC_NO) BETWEEN 6 AND 20)
    BEGIN
        RAISERROR('錯誤：新帳號不符合系統規則（6-20 個字元，以英文字母開頭）', 16, 1);
        ROLLBACK TRANSACTION;
        RETURN;
    END

    -- 驗證：新帳號不得為身分證格式
    IF @NEW_ACC_NO LIKE '[A-Za-z][12]________' AND LEN(@NEW_ACC_NO) = 10
    BEGIN
        RAISERROR('錯誤：新帳號不得為身分證格式', 16, 1);
        ROLLBACK TRANSACTION;
        RETURN;
    END

    -- 1. 複製舊會員資料，建立新帳號的會員記錄
    INSERT INTO MEMBER (
        ACC_NO, PSWD, IDN, SEX_CD, BIRTHDAY, NAME, ENAME, CNT_NAME, CNT_ENAME,
        CHR_NAME, CHR_ENAME, TEL, FAX, CNT_TEL, MAIL, CITY_CD, TOWN_CD, ADDR, EADDR,
        MEDICO, MAIL_MK, CARD_TYPE, CARD_INFO, CARD_IDX, SERIALNO, MOBILE, ONAME,
        LAST_LOGINDATE, DEL_MK, UPD_TIME, UPD_FUN_CD, UPD_ACC, ADD_TIME, ADD_FUN_CD, ADD_ACC
    )
    SELECT
        @NEW_ACC_NO,  -- 使用新帳號（手動指定或自動產生）
        PSWD, IDN, SEX_CD, BIRTHDAY, NAME, ENAME, CNT_NAME, CNT_ENAME,
        CHR_NAME, CHR_ENAME, TEL, FAX, CNT_TEL, MAIL, CITY_CD, TOWN_CD, ADDR, EADDR,
        MEDICO, MAIL_MK, CARD_TYPE, CARD_INFO, CARD_IDX, SERIALNO, MOBILE, ONAME,
        LAST_LOGINDATE, 'N',  -- 確保新記錄未刪除
        GETDATE(), 'ADMIN-ACC-UPDATE', 'ADMIN',  -- 更新資訊
        GETDATE(), 'ADMIN-ACC-UPDATE', 'ADMIN'   -- 新增資訊
    FROM MEMBER
    WHERE ACC_NO = @OLD_ACC_NO AND IDN = @IDN;

    -- 2. 更新 LOGIN_LOG 登入記錄
    UPDATE LOGIN_LOG
    SET LOGIN_ID = @NEW_ACC_NO
    WHERE LOGIN_ID = @OLD_ACC_NO;

    -- 3. 更新 APPLY 申請主檔（如果存在）
    IF OBJECT_ID('APPLY', 'U') IS NOT NULL
    BEGIN
        UPDATE APPLY
        SET ACC_NO = @NEW_ACC_NO,
            UPD_TIME = GETDATE(),
            UPD_FUN_CD = 'ADMIN-ACC-UPDATE',
            UPD_ACC = 'ADMIN'
        WHERE ACC_NO = @OLD_ACC_NO;
    END

    -- 4. 更新 APPLY_PAY 繳費記錄（如果存在）
    IF OBJECT_ID('APPLY_PAY', 'U') IS NOT NULL
    BEGIN
        UPDATE APPLY_PAY
        SET ACC_NO = @NEW_ACC_NO,
            UPD_TIME = GETDATE(),
            UPD_FUN_CD = 'ADMIN-ACC-UPDATE',
            UPD_ACC = 'ADMIN'
        WHERE ACC_NO = @OLD_ACC_NO;
    END

    -- 5. 更新 MESSAGE 訊息記錄（如果存在 RECEIVER_ACC_NO 欄位）
    IF OBJECT_ID('MESSAGE', 'U') IS NOT NULL
    BEGIN
        IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('MESSAGE') AND name = 'RECEIVER_ACC_NO')
        BEGIN
            UPDATE MESSAGE
            SET RECEIVER_ACC_NO = @NEW_ACC_NO
            WHERE RECEIVER_ACC_NO = @OLD_ACC_NO;
        END
    END

    -- 6. 更新 MAIL_LOG 郵件記錄（如果存在 ACC_NO 欄位）
    IF OBJECT_ID('MAIL_LOG', 'U') IS NOT NULL
    BEGIN
        IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('MAIL_LOG') AND name = 'ACC_NO')
        BEGIN
            UPDATE MAIL_LOG
            SET ACC_NO = @NEW_ACC_NO
            WHERE ACC_NO = @OLD_ACC_NO;
        END
    END

    -- 7. 軟刪除舊會員記錄
    UPDATE MEMBER
    SET DEL_MK = 'Y',
        DEL_TIME = GETDATE(),
        DEL_FUN_CD = 'ADMIN-ACC-UPDATE',
        DEL_ACC = 'ADMIN',
        UPD_TIME = GETDATE(),
        UPD_FUN_CD = 'ADMIN-ACC-UPDATE',
        UPD_ACC = 'ADMIN'
    WHERE ACC_NO = @OLD_ACC_NO AND IDN = @IDN;

    -- 顯示更新結果
    SELECT
        '更新成功' AS 狀態,
        @OLD_ACC_NO AS 舊帳號,
        @NEW_ACC_NO AS 新帳號,
        @IDN AS 身分證字號,
        CASE
            WHEN @NEW_ACC_NO LIKE 'MEM%' THEN '自動產生'
            ELSE '手動指定'
        END AS 帳號來源,
        GETDATE() AS 更新時間;

    -- 提交交易
    COMMIT TRANSACTION;
    PRINT '交易已提交';

END TRY
BEGIN CATCH
    -- 發生錯誤時回滾
    ROLLBACK TRANSACTION;

    -- 顯示錯誤訊息
    SELECT
        ERROR_NUMBER() AS 錯誤編號,
        ERROR_MESSAGE() AS 錯誤訊息,
        ERROR_LINE() AS 錯誤行號;

    PRINT '交易已回滾';
END CATCH;
```

### 步驟 5：批次更新帳號

**⚠ 警告：** 批次更新風險較高，建議先執行少量測試

#### 5.1 建立臨時對照表

**方式 A：自動產生所有新帳號**

```sql
-- 建立臨時對照表
IF OBJECT_ID('tempdb..#AccountMapping') IS NOT NULL
    DROP TABLE #AccountMapping;

CREATE TABLE #AccountMapping (
    OLD_ACC_NO NVARCHAR(50),
    NEW_ACC_NO NVARCHAR(50),
    IDN NVARCHAR(20),
    NAME NVARCHAR(100),
    MAIL NVARCHAR(200),
    IS_MANUAL BIT DEFAULT 0,  -- 0 = 自動產生, 1 = 手動指定
    PROCESSED BIT DEFAULT 0,
    PROCESS_TIME DATETIME NULL,
    ERROR_MSG NVARCHAR(500) NULL
);

-- 產生對照資料（自動產生新帳號）
INSERT INTO #AccountMapping (OLD_ACC_NO, NEW_ACC_NO, IDN, NAME, MAIL, IS_MANUAL)
SELECT
    ACC_NO AS OLD_ACC_NO,
    'MEM' + RIGHT('000000' + CAST(ROW_NUMBER() OVER (ORDER BY ADD_TIME) + 100000 AS VARCHAR), 6) AS NEW_ACC_NO,
    IDN,
    NAME,
    MAIL,
    0  -- 自動產生
FROM MEMBER
WHERE 1=1
    AND ISNULL(DEL_MK, 'N') = 'N'
    AND ACC_NO = IDN
    AND LEN(IDN) = 10;

-- 檢視對照表
SELECT
    OLD_ACC_NO AS 舊帳號,
    NEW_ACC_NO AS 新帳號,
    IDN AS 身分證字號,
    NAME AS 姓名,
    MAIL AS 電子郵件,
    CASE WHEN IS_MANUAL = 1 THEN '手動指定' ELSE '自動產生' END AS 帳號來源
FROM #AccountMapping
ORDER BY OLD_ACC_NO;
```

**方式 B：手動指定部分帳號 + 自動產生其他帳號**

```sql
-- 建立臨時對照表
IF OBJECT_ID('tempdb..#AccountMapping') IS NOT NULL
    DROP TABLE #AccountMapping;

CREATE TABLE #AccountMapping (
    OLD_ACC_NO NVARCHAR(50),
    NEW_ACC_NO NVARCHAR(50),
    IDN NVARCHAR(20),
    NAME NVARCHAR(100),
    MAIL NVARCHAR(200),
    IS_MANUAL BIT DEFAULT 0,
    PROCESSED BIT DEFAULT 0,
    PROCESS_TIME DATETIME NULL,
    ERROR_MSG NVARCHAR(500) NULL
);

-- 步驟 1：先插入手動指定的帳號（會員要求的帳號）
INSERT INTO #AccountMapping (OLD_ACC_NO, NEW_ACC_NO, IDN, NAME, MAIL, IS_MANUAL)
VALUES
    ('A123456789', 'john_wang', 'A123456789', '王小明', 'john@example.com', 1),
    ('B987654321', 'mary_lee', 'B987654321', '李小華', 'mary@example.com', 1),
    ('C111222333', 'peter_chen', 'C111222333', '陳大同', 'peter@example.com', 1);
    -- 可以繼續新增更多手動指定的帳號

-- 步驟 2：查詢目前最大的 MEM 流水號
DECLARE @MAX_SEQ INT;

SELECT @MAX_SEQ = ISNULL(MAX(CAST(SUBSTRING(ACC_NO, 4, 6) AS INT)), 100000)
FROM MEMBER
WHERE ACC_NO LIKE 'MEM%'
    AND LEN(ACC_NO) = 9
    AND ISNUMERIC(SUBSTRING(ACC_NO, 4, 6)) = 1;

-- 步驟 3：為其他會員自動產生新帳號
INSERT INTO #AccountMapping (OLD_ACC_NO, NEW_ACC_NO, IDN, NAME, MAIL, IS_MANUAL)
SELECT
    ACC_NO AS OLD_ACC_NO,
    'MEM' + RIGHT('000000' + CAST(ROW_NUMBER() OVER (ORDER BY ADD_TIME) + @MAX_SEQ AS VARCHAR), 6) AS NEW_ACC_NO,
    IDN,
    NAME,
    MAIL,
    0  -- 自動產生
FROM MEMBER
WHERE 1=1
    AND ISNULL(DEL_MK, 'N') = 'N'
    AND ACC_NO = IDN
    AND LEN(IDN) = 10
    AND ACC_NO NOT IN (SELECT OLD_ACC_NO FROM #AccountMapping);  -- 排除已手動指定的帳號

-- 檢視對照表
SELECT
    OLD_ACC_NO AS 舊帳號,
    NEW_ACC_NO AS 新帳號,
    IDN AS 身分證字號,
    NAME AS 姓名,
    MAIL AS 電子郵件,
    CASE WHEN IS_MANUAL = 1 THEN '手動指定' ELSE '自動產生' END AS 帳號來源
FROM #AccountMapping
ORDER BY IS_MANUAL DESC, OLD_ACC_NO;
```

#### 5.2 批次更新執行

```sql
-- 批次更新（使用 CURSOR）
DECLARE @OLD_ACC_NO NVARCHAR(50);
DECLARE @NEW_ACC_NO NVARCHAR(50);
DECLARE @IDN NVARCHAR(20);
DECLARE @ERROR_MSG NVARCHAR(500);
DECLARE @SUCCESS_COUNT INT = 0;
DECLARE @FAIL_COUNT INT = 0;

DECLARE account_cursor CURSOR FOR
SELECT OLD_ACC_NO, NEW_ACC_NO, IDN
FROM #AccountMapping
WHERE PROCESSED = 0;

OPEN account_cursor;

FETCH NEXT FROM account_cursor INTO @OLD_ACC_NO, @NEW_ACC_NO, @IDN;

WHILE @@FETCH_STATUS = 0
BEGIN
    BEGIN TRY
        BEGIN TRANSACTION;

        -- 驗證新帳號不存在
        IF EXISTS (SELECT 1 FROM MEMBER WHERE ACC_NO = @NEW_ACC_NO AND ISNULL(DEL_MK, 'N') = 'N')
        BEGIN
            SET @ERROR_MSG = '新帳號已存在';
            ROLLBACK TRANSACTION;

            UPDATE #AccountMapping
            SET PROCESSED = 1,
                PROCESS_TIME = GETDATE(),
                ERROR_MSG = @ERROR_MSG
            WHERE OLD_ACC_NO = @OLD_ACC_NO;

            SET @FAIL_COUNT = @FAIL_COUNT + 1;
        END
        ELSE
        BEGIN
            -- 1. 複製舊會員資料，建立新帳號的會員記錄
            INSERT INTO MEMBER (
                ACC_NO, PSWD, IDN, SEX_CD, BIRTHDAY, NAME, ENAME, CNT_NAME, CNT_ENAME,
                CHR_NAME, CHR_ENAME, TEL, FAX, CNT_TEL, MAIL, CITY_CD, TOWN_CD, ADDR, EADDR,
                MEDICO, MAIL_MK, CARD_TYPE, CARD_INFO, CARD_IDX, SERIALNO, MOBILE, ONAME,
                LAST_LOGINDATE, DEL_MK, UPD_TIME, UPD_FUN_CD, UPD_ACC, ADD_TIME, ADD_FUN_CD, ADD_ACC
            )
            SELECT
                @NEW_ACC_NO, PSWD, IDN, SEX_CD, BIRTHDAY, NAME, ENAME, CNT_NAME, CNT_ENAME,
                CHR_NAME, CHR_ENAME, TEL, FAX, CNT_TEL, MAIL, CITY_CD, TOWN_CD, ADDR, EADDR,
                MEDICO, MAIL_MK, CARD_TYPE, CARD_INFO, CARD_IDX, SERIALNO, MOBILE, ONAME,
                LAST_LOGINDATE, 'N', GETDATE(), 'ADMIN-BATCH-UPDATE', 'ADMIN', GETDATE(), 'ADMIN-BATCH-UPDATE', 'ADMIN'
            FROM MEMBER WHERE ACC_NO = @OLD_ACC_NO;

            -- 2. 更新所有相關資料表
            UPDATE LOGIN_LOG SET LOGIN_ID = @NEW_ACC_NO WHERE LOGIN_ID = @OLD_ACC_NO;

            IF OBJECT_ID('APPLY', 'U') IS NOT NULL
                UPDATE APPLY SET ACC_NO = @NEW_ACC_NO, UPD_TIME = GETDATE(), UPD_FUN_CD = 'ADMIN-BATCH-UPDATE', UPD_ACC = 'ADMIN' WHERE ACC_NO = @OLD_ACC_NO;

            IF OBJECT_ID('APPLY_PAY', 'U') IS NOT NULL
                UPDATE APPLY_PAY SET ACC_NO = @NEW_ACC_NO, UPD_TIME = GETDATE(), UPD_FUN_CD = 'ADMIN-BATCH-UPDATE', UPD_ACC = 'ADMIN' WHERE ACC_NO = @OLD_ACC_NO;

            IF OBJECT_ID('MESSAGE', 'U') IS NOT NULL AND EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('MESSAGE') AND name = 'RECEIVER_ACC_NO')
                UPDATE MESSAGE SET RECEIVER_ACC_NO = @NEW_ACC_NO WHERE RECEIVER_ACC_NO = @OLD_ACC_NO;

            IF OBJECT_ID('MAIL_LOG', 'U') IS NOT NULL AND EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('MAIL_LOG') AND name = 'ACC_NO')
                UPDATE MAIL_LOG SET ACC_NO = @NEW_ACC_NO WHERE ACC_NO = @OLD_ACC_NO;

            -- 3. 軟刪除舊會員記錄
            UPDATE MEMBER SET DEL_MK = 'Y', DEL_TIME = GETDATE(), DEL_FUN_CD = 'ADMIN-BATCH-UPDATE', DEL_ACC = 'ADMIN',
                UPD_TIME = GETDATE(), UPD_FUN_CD = 'ADMIN-BATCH-UPDATE', UPD_ACC = 'ADMIN'
            WHERE ACC_NO = @OLD_ACC_NO;

            COMMIT TRANSACTION;

            UPDATE #AccountMapping
            SET PROCESSED = 1,
                PROCESS_TIME = GETDATE(),
                ERROR_MSG = NULL
            WHERE OLD_ACC_NO = @OLD_ACC_NO;

            SET @SUCCESS_COUNT = @SUCCESS_COUNT + 1;

            PRINT '成功更新：' + @OLD_ACC_NO + ' -> ' + @NEW_ACC_NO;
        END

    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;

        SET @ERROR_MSG = ERROR_MESSAGE();

        UPDATE #AccountMapping
        SET PROCESSED = 1,
            PROCESS_TIME = GETDATE(),
            ERROR_MSG = @ERROR_MSG
        WHERE OLD_ACC_NO = @OLD_ACC_NO;

        SET @FAIL_COUNT = @FAIL_COUNT + 1;

        PRINT '更新失敗：' + @OLD_ACC_NO + ' - ' + @ERROR_MSG;
    END CATCH

    FETCH NEXT FROM account_cursor INTO @OLD_ACC_NO, @NEW_ACC_NO, @IDN;
END

CLOSE account_cursor;
DEALLOCATE account_cursor;

-- 顯示批次更新結果
SELECT
    @SUCCESS_COUNT AS 成功數量,
    @FAIL_COUNT AS 失敗數量,
    (@SUCCESS_COUNT + @FAIL_COUNT) AS 總數量;

-- 顯示失敗的記錄
SELECT * FROM #AccountMapping WHERE ERROR_MSG IS NOT NULL;
```

### 步驟 6：驗證更新結果

#### 6.1 驗證更新後的資料

```sql
-- 6.1.1 確認沒有 ACC_NO = IDN 的會員
SELECT
    COUNT(*) AS 仍有問題的會員數量
FROM MEMBER
WHERE 1=1
    AND ISNULL(DEL_MK, 'N') = 'N'
    AND ACC_NO = IDN
    AND LEN(IDN) = 10;

-- 預期結果：0

-- 6.1.2 檢視更新後的會員資料
SELECT
    ACC_NO AS 新帳號,
    IDN AS 身分證字號,
    NAME AS 姓名,
    MAIL AS Email,
    UPD_TIME AS 更新時間,
    UPD_FUN_CD AS 更新功能
FROM MEMBER
WHERE UPD_FUN_CD IN ('ADMIN-ACC-UPDATE', 'ADMIN-BATCH-UPDATE')
ORDER BY UPD_TIME DESC;

-- 6.1.3 驗證關聯資料的一致性
-- 檢查是否有孤兒記錄（關聯資料的 ACC_NO 在 MEMBER 中不存在）
SELECT 'LOGIN_LOG 孤兒記錄' AS 資料表, COUNT(*) AS 數量
FROM LOGIN_LOG L
WHERE NOT EXISTS (SELECT 1 FROM MEMBER M WHERE M.ACC_NO = L.LOGIN_ID)

UNION ALL

SELECT 'APPLY 孤兒記錄', COUNT(*)
FROM APPLY A
WHERE NOT EXISTS (SELECT 1 FROM MEMBER M WHERE M.ACC_NO = A.ACC_NO)

UNION ALL

SELECT 'APPLY_PAY 孤兒記錄', COUNT(*)
FROM APPLY_PAY P
WHERE NOT EXISTS (SELECT 1 FROM MEMBER M WHERE M.ACC_NO = P.ACC_NO);

-- 預期結果：所有數量都應該是 0
```

#### 6.2 產生更新前後對照報表

```sql
-- 從臨時對照表產生報表
SELECT
    OLD_ACC_NO AS 原帳號,
    NEW_ACC_NO AS 新帳號,
    IDN AS 身分證字號,
    NAME AS 姓名,
    MAIL AS Email,
    CASE WHEN PROCESSED = 1 THEN '已處理' ELSE '未處理' END AS 處理狀態,
    PROCESS_TIME AS 處理時間,
    ERROR_MSG AS 錯誤訊息
FROM #AccountMapping
ORDER BY PROCESSED, OLD_ACC_NO;

-- 匯出為 CSV 供存檔
-- 可使用 SSMS 的「將結果儲存為」功能
```

### 步驟 7：通知會員

#### 7.1 產生通知名單

```sql
-- 產生需要通知的會員清單
SELECT
    M.ACC_NO AS 新帳號,
    AM.OLD_ACC_NO AS 原帳號,
    M.NAME AS 姓名,
    M.MAIL AS Email,
    M.MOBILE AS 手機,
    '親愛的 ' + M.NAME + ' 您好，' + CHAR(13) + CHAR(10) +
    '因應資訊安全政策，您的帳號已從 ' + AM.OLD_ACC_NO + ' 更新為 ' + M.ACC_NO + '。' + CHAR(13) + CHAR(10) +
    '密碼維持不變，請使用新帳號登入。' + CHAR(13) + CHAR(10) +
    '如有任何問題，請聯絡客服。' AS 通知內容
FROM MEMBER M
INNER JOIN #AccountMapping AM ON M.ACC_NO = AM.NEW_ACC_NO
WHERE AM.PROCESSED = 1 AND AM.ERROR_MSG IS NULL
ORDER BY M.ACC_NO;
```

#### 7.2 建議通知方式

1. **Email 通知**：使用系統的郵件發送功能
2. **簡訊通知**：針對有手機號碼的會員
3. **系統訊息**：在會員登入後顯示通知
4. **公告**：在網站首頁公告此變更

### 步驟 8：清理臨時資料

```sql
-- 確認所有更新都已完成後，清理臨時對照表
IF OBJECT_ID('tempdb..#AccountMapping') IS NOT NULL
    DROP TABLE #AccountMapping;

PRINT '臨時對照表已清理';
```

## 注意事項

### 執行前檢查清單

- [ ] 已在測試環境完整測試
- [ ] 已備份生產環境資料庫
- [ ] 已確認離峰時段執行時間
- [ ] 已通知相關人員（IT、客服）
- [ ] 已準備回滾計畫

### 執行中監控

- [ ] 監控資料庫效能
- [ ] 監控錯誤日誌
- [ ] 記錄執行時間
- [ ] 記錄成功/失敗數量

### 執行後驗證

- [ ] 確認沒有 ACC_NO = IDN 的記錄
- [ ] 確認沒有孤兒記錄
- [ ] 確認會員可以使用新帳號登入
- [ ] 確認申請案件資料正確
- [ ] 確認繳費記錄正確

### 回滾計畫

如果更新後發現問題，可以使用備份還原：

```sql
-- 方案 A：從備份還原整個資料庫
RESTORE DATABASE [YourDatabase]
FROM DISK = 'C:\Backup\YourDatabase_BeforeUpdate.bak'
WITH REPLACE;

-- 方案 B：如果有保留對照表，可以反向更新
-- （需要在更新前將對照表儲存到永久表）
```

## 常見問題

### Q1：如果會員在更新期間登入會怎樣？

**A：** 建議在離峰時段執行，並在更新期間暫時停用登入功能。可以在 `Global.asax.cs` 中加入維護模式檢查。

### Q2：如果新帳號產生重複怎麼辦？

**A：** 腳本中已包含重複檢查。如果發生重複，該筆記錄會標記為失敗，需要手動處理。

### Q3：更新後會員的密碼會改變嗎？

**A：** 不會。密碼（PSWD）欄位不會被更新，會員可以使用原密碼登入。

### Q4：如何確認所有關聯資料都已更新？

**A：** 使用步驟 6.1.3 的孤兒記錄檢查 SQL，確認所有關聯資料的 ACC_NO 都存在於 MEMBER 表中。

### Q5：可以只更新部分會員嗎？

**A：** 可以。在步驟 5.1 的 INSERT 語句中加入額外的 WHERE 條件，例如：

```sql
AND LAST_LOGINDATE < '2024-01-01'  -- 只更新 2024 年前登入的會員
```

## 附錄：完整執行範例

以下是一個完整的執行範例（測試環境）：

```sql
-- ========================================
-- 完整執行範例（請在測試環境執行）
-- ========================================

-- 1. 查詢問題帳號
SELECT COUNT(*) AS 問題帳號數量
FROM MEMBER
WHERE ISNULL(DEL_MK, 'N') = 'N' AND ACC_NO = IDN AND LEN(IDN) = 10;

-- 2. 建立對照表
IF OBJECT_ID('tempdb..#AccountMapping') IS NOT NULL DROP TABLE #AccountMapping;
CREATE TABLE #AccountMapping (
    OLD_ACC_NO NVARCHAR(50), NEW_ACC_NO NVARCHAR(50), IDN NVARCHAR(20),
    NAME NVARCHAR(100), MAIL NVARCHAR(200), PROCESSED BIT DEFAULT 0,
    PROCESS_TIME DATETIME NULL, ERROR_MSG NVARCHAR(500) NULL
);

INSERT INTO #AccountMapping (OLD_ACC_NO, NEW_ACC_NO, IDN, NAME, MAIL)
SELECT ACC_NO, 'MEM' + RIGHT('000000' + CAST(ROW_NUMBER() OVER (ORDER BY ADD_TIME) + 100000 AS VARCHAR), 6),
       IDN, NAME, MAIL
FROM MEMBER
WHERE ISNULL(DEL_MK, 'N') = 'N' AND ACC_NO = IDN AND LEN(IDN) = 10;

-- 3. 檢視對照表
SELECT * FROM #AccountMapping;

-- 4. 執行批次更新（請確認後執行）
-- （使用步驟 5.2 的批次更新腳本）

-- 5. 驗證結果
SELECT COUNT(*) AS 剩餘問題帳號 FROM MEMBER WHERE ISNULL(DEL_MK, 'N') = 'N' AND ACC_NO = IDN AND LEN(IDN) = 10;

-- 6. 產生報表
SELECT * FROM #AccountMapping ORDER BY PROCESSED, OLD_ACC_NO;

-- 7. 清理
DROP TABLE #AccountMapping;
```

---

**文件版本：** 1.0
**建立日期：** 2025-10-10
**最後更新：** 2025-10-10
**作者：** 柏通股份有限公司
